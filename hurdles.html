<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Animation Preview</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles for the canvas to ensure it scales responsively */
        canvas {
            display: block;
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            max-width: 800px; /* Optional: limit max width for very large screens */
            margin: 0 auto; /* Center the canvas */
            border: 1px solid #ccc;
            background: #fff;
            border-radius: 0.5rem; /* Rounded corners for the canvas */
        }
        /* Ensure the body uses Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Styles for the new container wrapping canvas and controls */
        .canvas-container {
            position: relative; /* Essential for absolute positioning of controls */
            width: 100%;
            max-width: 800px; /* Match canvas max-width */
            margin: 0 auto; /* Center the container */
        }
        /* Styles for the D-pad container */
        .dpad-controls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            width: 100px; /* Adjusted size for better usability */
            height: 100px; /* Adjusted size for better usability */
            background-color: #333; /* Dark background for the D-pad */
            border-radius: 50%; /* Circular shape */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 2px solid #222;
            opacity: 0.5; /* Made transparent */
        }

        .dpad-button {
            position: absolute;
            width: 35px; /* Adjusted size for better usability */
            height: 35px; /* Adjusted size for better usability */
            background-color: #555; /* Lighter background for buttons */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
            border: 1px solid #444;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }

        .dpad-button:active {
            background-color: #777;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        /* Positioning for individual D-pad buttons */
        #upBtn { top: 0; transform: translateY(-50%); }
        #downBtn { bottom: 0; transform: translateY(50%); }
        #leftBtn { left: 0; transform: translateX(-50%); }
        #rightBtn { right: 0; transform: translateX(50%); }

        /* Center dot */
        .dpad-center {
            width: 25px; /* Adjusted size for better usability */
            height: 25px; /* Adjusted size for better usability */
            background-color: #222;
            border-radius: 50%;
            position: absolute;
            z-index: 1; /* Ensure it's behind the buttons */
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.4);
        }

        /* SVG arrow styling and color coding */
        .arrow-icon {
            width: 15px; /* Adjusted size for better usability */
            height: 15px; /* Adjusted size for better usability */
            fill: white; /* Default fill color for arrows */
        }

        /* PlayStation-like color coding for arrows */
        #upBtn .arrow-icon { fill: #4CAF50; /* Green */ }
        #downBtn .arrow-icon { fill: #F44336; /* Red */ }
        #leftBtn .arrow-icon { fill: #2196F3; /* Blue */ }
        #rightBtn .arrow-icon { fill: #E91E63; /* Pink */ }

        /* Styles for diagonal buttons */
        .dpad-diagonal-button {
            position: absolute;
            width: 20px; /* Tiny size */
            height: 20px; /* Tiny size */
            background-color: #666; /* Neutral background */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
            border: 0.5px solid #555;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: background-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            opacity: 0.5; /* Transparent */
        }

        .dpad-diagonal-button:active {
            background-color: #888;
            box-shadow: inset 0 0.5px 1px rgba(0, 0, 0, 0.15);
        }

        /* Positioning for diagonal buttons */
        /* 1:30 o'clock (Up-Right) */
        #upRightBtn {
            top: 15%; /* Adjust as needed */
            right: 15%; /* Adjust as needed */
            transform: translate(50%, -50%); /* Centering adjustment */
        }
        /* 4:30 o'clock (Down-Right) */
        #downRightBtn {
            bottom: 15%; /* Adjust as needed */
            right: 15%; /* Adjust as needed */
            transform: translate(50%, 50%); /* Centering adjustment */
        }
        /* 7:30 o'clock (Down-Left) */
        #downLeftBtn {
            bottom: 15%; /* Adjust as needed */
            left: 15%; /* Adjust as needed */
            transform: translate(-50%, 50%); /* Centering adjustment */
        }
        /* 10:30 o'clock (Up-Left) */
        #upLeftBtn {
            top: 15%; /* Adjust as needed */
            left: 15%; /* Adjust as needed */
            transform: translate(-50%, -50%); /* Centering adjustment */
        }

        /* Diagonal button icon (simple dot) */
        .dpad-diagonal-button .dot-icon {
            width: 8px; /* Size of the dot */
            height: 8px;
            background-color: white; /* White dot */
            border-radius: 50%;
        }

        /* New style for the action button (Start/Reset) */
        #actionButton {
            position: absolute;
            top: 10%; /* Adjust vertical position as needed */
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100; /* Ensure it's above other elements */
            padding: 0.75rem 1.5rem;
            font-size: 1.25rem;
            font-weight: bold;
            color: white;
            background-color: #4CAF50; /* Green */
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: background-color 0.3s ease, transform 0.3s ease;
        }

        #actionButton:hover {
            background-color: #45a049;
            transform: translate(-50%, -50%) scale(1.05);
        }

        #actionButton:active {
            background-color: #3e8e41;
            transform: translate(-50%, -50%) scale(0.95);
        }

    </style>
</head>
<body class="bg-gradient-to-br from-blue-100 to-purple-100 min-h-screen flex flex-col items-center justify-center p-4 relative">
    <div class="bg-white p-6 rounded-xl shadow-lg mb-6 w-full max-w-4xl">
        <p class="text-gray-700 mb-4 text-center text-sm sm:text-base">Press <span class="font-bold text-blue-600">SPACEBAR</span> to start/reset. Use A/D to move left/right, W to jump, S to crouch. On-screen D-pad controls simulate these keys, allowing for simultaneous actions (e.g., holding 'Up' and 'Right' to jump while moving right).</p>
        
        <!-- Toggle Controls Button -->
        <div class="flex justify-center mb-4">
            <button id="toggleControlsBtn" class="bg-gray-600 hover:bg-gray-800 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                Show UI
            </button>
        </div>

        <div id="controls" class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm sm:text-base" style="display: none;">
            <div class="flex flex-col space-y-2">
                <label for="manualMode" class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="manualMode" class="form-checkbox h-4 w-4 text-blue-600 rounded focus:ring-blue-500">
                    <span>Manual Run Mode</span>
                </label>

                <label for="manualSpeedMultiplier" class="flex flex-col">
                    <span>Manual Speed Multiplier: <span id="manualSpeedMultiplierValue" class="font-semibold">0.5</span></span>
                    <input type="range" id="manualSpeedMultiplier" min="0.1" max="2" step="0.05" value="0.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="tapCurveExponent" class="flex flex-col">
                    <span>Tap Curve Exponent: <span id="tapCurveExponentValue" class="font-semibold">0.4</span></span>
                    <input type="range" id="tapCurveExponent" min="0.1" max="1.0" step="0.05" value="0.4" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="speed" class="flex flex-col">
                    <span>Speed: <span id="speedValue" class="font-semibold">2.5</span></span>
                    <input type="range" id="speed" min="1" max="2.5" step="0.05" value="2.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="expression" class="flex flex-col">
                    <span>Expression:</span>
                    <select id="expression" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
                        <option value="neutral" selected>Neutral</option>
                        <option value="happy">Happy</option>
                        <option value="sad">Sad</option>
                        <option value="angry">Angry</option>
                        <option value="surprised">Surprised</option>
                        <option value="tired">Tired</option>
                        <option value="trying">Trying</option>
                    </select>
                </label>

                <label for="crouchExtraBend" class="flex flex-col">
                    <span>Crouch Extra Bend: <span id="crouchExtraBendValue" class="font-semibold">0.9</span></span>
                    <input type="range" id="crouchExtraBend" min="0" max="1.5" step="0.05" value="0.9" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <strong class="mt-4 text-gray-800">Right Direction (dir=1):</strong>
                <label for="gaitAmplitude" class="flex flex-col">
                    <span>Gait Amplitude: <span id="gaitAmplitudeValue" class="font-semibold">0.9</span></span>
                    <input type="range" id="gaitAmplitude" min="0" max="2" step="0.05" value="0.9" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="stepFrequency" class="flex flex-col">
                    <span>Step Frequency: <span id="stepFrequencyValue" class="font-semibold">0.05</span></span>
                    <input type="range" id="stepFrequency" min="0.05" max="0.2" step="0.01" value="0.05" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>
                
                <label for="armSwingMultiplier" class="flex flex-col">
                    <span>Arm Swing Multiplier: <span id="armSwingMultiplierValue" class="font-semibold">0.75</span></span>
                    <input type="range" id="armSwingMultiplier" min="0" max="2" step="0.05" value="0.75" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>
            </div>

            <div class="flex flex-col space-y-2">
                <label for="frontKneeBend" class="flex flex-col">
                    <span>Front Knee Bend: <span id="frontKneeBendValue" class="font-semibold">0.4</span></span>
                    <input type="range" id="frontKneeBend" min="0" max="1" step="0.05" value="0.4" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMax" class="flex flex-col">
                    <span>Back Knee Bend Max: <span id="backKneeBendMaxValue" class="font-semibold">0.7</span></span>
                    <input type="range" id="backKneeBendMax" min="0" max="1.5" step="0.05" value="0.7" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMultiplier" class="flex flex-col">
                    <span>Back Knee Bend Multiplier: <span id="backKneeBendMultiplierValue" class="font-semibold">2.5</span></span>
                    <input type="range" id="backKneeBendMultiplier" min="1" max="4" step="0.1" value="2.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="elbowBend" class="flex flex-col">
                    <span>Elbow Bend: <span id="elbowBendValue" class="font-semibold">1.2</span></span>
                    <input type="range" id="elbowBend" min="0" max="4" step="0.05" value="1.2" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="torsoThickness" class="flex flex-col">
                    <span>Torso Thickness: <span id="torsoThicknessValue" class="font-semibold">2</span></span>
                    <input type="range" id="torsoThickness" min="1" max="10" step="0.5" value="2" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <strong class="mt-4 text-gray-800">Left Direction (dir=-1):</strong>
                <label for="gaitAmplitudeLeft" class="flex flex-col">
                    <span>Gait Amplitude Left: <span id="gaitAmplitudeLeftValue" class="font-semibold">0.9</span></span>
                    <input type="range" id="gaitAmplitudeLeft" min="0" max="2" step="0.05" value="0.9" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="stepFrequencyLeft" class="flex flex-col">
                    <span>Step Frequency Left: <span id="stepFrequencyLeftValue" class="font-semibold">0.05</span></span>
                    <input type="range" id="stepFrequencyLeft" min="0.05" max="0.2" step="0.01" value="0.05" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="frontKneeBendLeft" class="flex flex-col">
                    <span>Front Knee Bend Left: <span id="frontKneeBendLeftValue" class="font-semibold">0.4</span></span>
                    <input type="range" id="frontKneeBendLeft" min="0" max="1" step="0.05" value="0.4" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMaxLeft" class="flex flex-col">
                    <span>Back Knee Bend Max Left: <span id="backKneeBendMaxLeftValue" class="font-semibold">0.7</span></span>
                    <input type="range" id="backKneeBendMaxLeft" min="0" max="1.5" step="0.05" value="0.7" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMultiplierLeft" class="flex flex-col">
                    <span>Back Knee Bend Multiplier Left: <span id="backKneeBendMultiplierLeftValue" class="font-semibold">2.5</span></span>
                    <input type="range" id="backKneeBendMultiplierLeft" min="1" max="4" step="0.1" value="2.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="elbowBendLeft" class="flex flex-col">
                    <span>Elbow Bend Left: <span id="elbowBendLeftValue" class="font-semibold">1.2</span></span>
                    <input type="range" id="elbowBendLeft" min="0" max="4" step="0.05" value="1.2" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="torsoThicknessLeft" class="flex flex-col">
                    <span>Torso Thickness Left: <span id="torsoThicknessLeftValue" class="font-semibold">3</span></span>
                    <input type="range" id="torsoThicknessLeft" min="1" max="10" step="0.5" value="3" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="armSwingMultiplierLeft" class="flex flex-col">
                    <span>Arm Swing Multiplier Left: <span id="armSwingMultiplierLeftValue" class="font-semibold">1</span></span>
                    <input type="range" id="armSwingMultiplierLeft" min="0" max="2" step="0.05" value="1" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <strong class="mt-4 text-gray-800">Hurdle Pose Adjustments:</strong>
                <label for="hurdleLeadKneeBend" class="flex flex-col">
                    <span>Hurdle Lead Knee Bend: <span id="hurdleLeadKneeBendValue" class="font-semibold">0.84</span></span>
                    <input type="range" id="hurdleLeadKneeBend" min="0" max="1.0" step="0.01" value="0.84" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>
                <label for="hurdleTrailKneeBend" class="flex flex-col">
                    <span>Hurdle Trail Knee Bend: <span id="hurdleTrailKneeBendValue" class="font-semibold">0.85</span></span>
                    <input type="range" id="hurdleTrailKneeBend" min="0.5" max="3.0" step="0.05" value="0.85" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>
            </div>
        </div>
    </div>
    <div class="canvas-container">
        <canvas id="c" width="600" height="400" class="shadow-xl"></canvas>

        <!-- New Action Button (Start/Reset) -->
        <button id="actionButton">Start</button>

        <!-- D-pad Controls -->
        <div class="dpad-controls">
            <div class="dpad-center"></div>
            <button id="upBtn" class="dpad-button">
                <svg class="arrow-icon" viewBox="0 0 24 24">
                    <path d="M7 14l5-5 5 5z"/>
                </svg>
            </button>
            <button id="downBtn" class="dpad-button">
                <svg class="arrow-icon" viewBox="0 0 24 24">
                    <path d="M7 10l5 5 5-5z"/>
                </svg>
            </button>
            <button id="leftBtn" class="dpad-button">
                <svg class="arrow-icon" viewBox="0 0 24 24">
                    <path d="M14 7l-5 5 5 5z"/>
                </svg>
            </button>
            <button id="rightBtn" class="dpad-button">
                <svg class="arrow-icon" viewBox="0 0 24 24">
                    <path d="M10 7l5 5-5 5z"/>
                </svg>
            </button>

            <!-- Diagonal Buttons -->
            <button id="upRightBtn" class="dpad-diagonal-button">
                <div class="dot-icon"></div>
            </button>
            <button id="downRightBtn" class="dpad-diagonal-button">
                <div class="dot-icon"></div>
            </button>
            <button id="downLeftBtn" class="dpad-diagonal-button">
                <div class="dot-icon"></div>
            </button>
            <button id="upLeftBtn" class="dpad-diagonal-button">
                <div class="dot-icon"></div>
            </button>
        </div>
    </div>

    <script>
        // Wrap all JavaScript code in a DOMContentLoaded listener
        document.addEventListener('DOMContentLoaded', (event) => {
            // Get canvas and its 2D rendering context
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');

            // Get control elements from the DOM
            const speedSelect = document.getElementById('speed');
            const expressionSelect = document.getElementById('expression');
            const manualModeCheckbox = document.getElementById('manualMode');
            const manualSpeedMultiplierSelect = document.getElementById('manualSpeedMultiplier');
            const tapCurveExponentSelect = document.getElementById('tapCurveExponent'); // New slider
            // New arm swing sliders
            const armSwingMultiplierSelect = document.getElementById('armSwingMultiplier');
            const armSwingMultiplierLeftSelect = document.getElementById('armSwingMultiplierLeft');

            // Hurdle pose sliders
            const hurdleLeadKneeBendSelect = document.getElementById('hurdleLeadKneeBend');
            const hurdleTrailKneeBendSelect = document.getElementById('hurdleTrailKneeBend');


            // D-pad control buttons
            const leftBtn = document.getElementById('leftBtn');
            const rightBtn = document.getElementById('rightBtn');
            const upBtn = document.getElementById('upBtn');
            const downBtn = document.getElementById('downBtn');

            // Diagonal buttons
            const upRightBtn = document.getElementById('upRightBtn');
            const downRightBtn = document.getElementById('downRightBtn');
            const downLeftBtn = document.getElementById('downLeftBtn');
            const upLeftBtn = document.getElementById('upLeftBtn');

            // Get the toggle controls button and the controls div
            const toggleControlsBtn = document.getElementById('toggleControlsBtn');
            const controlsDiv = document.getElementById('controls');

            // Get the new action button (Start/Reset)
            const actionButton = document.getElementById('actionButton');

            // Animation and game state variables
            let position = 0; // Horizontal position of the stickman
            let y; // Vertical position of the stickman's hip (computed each frame)
            let vy = 0; // Vertical velocity for jumping
            let dir = 1; // Direction of movement (1 for right, -1 for left)
            let onGround = true; // Flag to check if stickman is on the ground
            let stepCycle = 0; // Controls the walking animation phase
            let keys = {}; // Stores the state of pressed keys

            let blinkTimer = 0; // Timer for eye blinking
            let isBlinking = false; // Flag for current blinking state
            let nextBlinkTime = getNextBlinkTime(); // When the next blink should occur

            let isCrouching = false; // Flag for crouching state
            let isHurling = false; // New flag for hurdle pose

            // Variables for manual run mode (Z/X and C/V tapping)
            let leftTapState = 0; // 0: expect Z, 1: expect X
            let rightTapState = 0; // 0: expect C, 1: expect V
            let lastLeftTapTime = 0; // Timestamp of last left tap
            let lastRightTapTime = 0; // Timestamp of last right tap
            let currentLeftSpeed = 0; // Calculated speed from left taps
            let currentRightSpeed = 0; // Calculated speed from right taps

            // Game State variables
            let gameState = 'idle'; // 'idle', 'countdown', 'running', 'finished'
            let startTime = 0; // Timestamp when the game starts running
            let finalTime = 0; // Stores the time when the race finishes
            let animationFrameId; // To store the requestAnimationFrame ID for cancellation

            // Countdown message variables for canvas drawing
            let currentCountdownMessage = '';
            let countdownMessageEndTime = 0;

            // Flag to control visibility of debug info and control panel
            let showUI = false; // Default to hidden

            // Speed penalty variables
            let speedPenaltyActive = false;
            let speedPenaltyEndTime = 0;

            // Hurdle data: { meterPosition: number, lane: number, isFallen: boolean }
            const hurdles = [];
            const initialHurdleMeter = 9;
            const hurdleInterval = 9;
            const numberOfHurdles = 9; // 1 original + 8 more

            // New variables for tracking cleared hurdles
            let hurdlesClearedCount = 0;
            let lastHurdleIndexPassed = -1; // Index of the last hurdle the stickman successfully passed
            let hurdle3Cleared = false; // Flag for hurdle 3
            let hurdle4Cleared = false; // Flag for hurdle 4


            // Top 3 Times storage
            let highScores = [];
            const MAX_HIGH_SCORES = 3;
            const HIGHSCORE_STORAGE_KEY = 'stickmanHighScores';

            // Tone.js setup for sound effects
            const mainSynth = new Tone.Synth().toDestination().set({ volume: -10 }); // For beeps
            
            // Original hurdle collision sound
            const hurdleSynth = new Tone.MembraneSynth().toDestination();
            hurdleSynth.volume.value = 0; // Set hurdle synth volume to 0dB (full volume)

            // New Tone.Player for the "aww" sound effect
            const awwPlayer = new Tone.Player({
                url: 'https://raw.githubusercontent.com/zapback100/Dads-Games/main/aww-8277.mp3',
                autostart: false,
                volume: 0 // Default volume, adjust as needed
            }).toDestination();

            // New Tone.Player for the "hell yeah" sound effect
            const hellYeahPlayer = new Tone.Player({
                url: 'https://raw.githubusercontent.com/zapback100/Dads-Games/main/hell-yeah-shout-101933.mp3',
                autostart: false,
                volume: 0 // Default volume, adjust as needed
            }).toDestination();

            // New Tone.Player for the "oh yeah" sound effect
            const ohYeahPlayer = new Tone.Player({
                url: 'https://raw.githubusercontent.com/zapback100/Dads-Games/main/oh-yeah-96951.mp3',
                autostart: false,
                volume: 0 // Default volume, adjust as needed
            }).toDestination();

            // Crowd cheering setup - Using Tone.Player for MP3 file
            const crowdPlayer = new Tone.Player({
                url: 'https://raw.githubusercontent.com/zapback100/Dads-Games/main/applause-sound-effect-240470.mp3',
                loop: true,
                autostart: false,
                volume: -Infinity // Start muted, will be adjusted
            }).toDestination(); // Ensure it's connected to destination

            // Flag to track if crowd sound is currently active (playing)
            let isCrowdSoundActive = false;

            // Listen for when the crowd sound is loaded
            crowdPlayer.onload = () => {
                console.log("Crowd sound loaded successfully!");
            };
            crowdPlayer.onerror = (e) => {
                console.error("Error loading crowd sound:", e);
            };

            awwPlayer.onload = () => {
                console.log("Aww sound loaded successfully!");
            };
            awwPlayer.onerror = (e) => {
                console.error("Error loading aww sound:", e);
            };

            hellYeahPlayer.onload = () => {
                console.log("Hell Yeah sound loaded successfully!");
            };
            hellYeahPlayer.onerror = (e) => {
                console.error("Error loading Hell Yeah sound:", e);
            };

            ohYeahPlayer.onload = () => {
                console.log("Oh Yeah sound loaded successfully!");
            };
            ohYeahPlayer.onerror = (e) => {
                console.error("Error loading Oh Yeah sound:", e);
            };


            const beepFrequencies = {
                'Ready!': 'C4',
                'Set!': 'D4',
                'Go!': 'G4'
            };

            // Fixed ground line (relative to canvas height)
            const groundYRatio = 300 / 400; // Original ratio for ground position
            let groundY; // Will be calculated based on current canvas height

            const numLanes = 8; // Number of running lanes
            let laneHeight; // Will be calculated dynamically
            let stickmanLane = 2; // The lane the stickman is in (1-indexed)
            let stickmanGroundY; // The effective ground Y for the stickman in their lane

            // Leg constants (consistent lengths for walking and crouching)
            const upperLegLen = 20;
            const lowerLegLen = 25;
            const footRadius = 2; // Reverted to original size
            const footHeight = footRadius * 2; // Equivalent height for collision/positioning (approximate diameter)

            // Arm constants
            const upperArmLen = 19.36;
            const lowerArmLen = 19.36;

            // Maximum strides per second
            const MAX_STRIDES_PER_SECOND = 4;
            // Calculate the maximum stepCycle advance per frame
            // A full stride is 2 * Math.PI units of stepCycle.
            // Assuming 60 frames per second, the max advance per frame is (MAX_STRIDES_PER_SECOND * 2 * Math.PI) / 60.
            const MAX_STEPCYCLE_ADVANCE_PER_FRAME = (MAX_STRIDES_PER_SECOND * 2 * Math.PI) / 60;

            // Global variable for pixels per meter, updated in updateDimensions
            let pixelsPerMeter = 50; // Base value, will be scaled

            // New: Offset for runner's initial position relative to the start line (in meters)
            // This value is calculated to place the runner's center on the '2' marker.
            const initialRunnerOffsetMeters = -0.2; // Negative value to move runner left of the start line
            const finishLineMeter = 100; // Finish line at 100 meters

            // Cloud data - initial positions and parallax factors
            const clouds = [
                { initialX: 100, y: 50, width: 60, height: 30, parallaxFactor: 0.1 },
                { initialX: 300, y: 80, width: 80, height: 40, parallaxFactor: 0.05 },
                { initialX: 550, y: 60, width: 70, height: 35, parallaxFactor: 0.08 },
                { initialX: 700, y: 90, width: 50, height: 25, parallaxFactor: 0.12 }
            ];

            // Function to update dimensions based on current canvas size
            function updateDimensions() {
                groundY = canvas.height * groundYRatio; // Calculate ground Y based on canvas height
                laneHeight = (canvas.height - groundY) / numLanes; // Calculate height of each lane
                // Calculate stickman's effective ground Y for their lane, centered
                stickmanGroundY = groundY + (stickmanLane - 1) * laneHeight + laneHeight / 2;
                pixelsPerMeter = 50 * (canvas.width / 600); // Update scaled pixelsPerMeter based on canvas width
            }

            // Function to resize canvas
            function resizeCanvas() {
                const containerWidth = canvas.parentElement.clientWidth;
                // Maintain a reasonable aspect ratio, e.g., 3:2
                const newWidth = Math.min(containerWidth, 800); // Max width of 800px
                const newHeight = (newWidth / 3) * 2; // 3:2 aspect ratio

                canvas.width = newWidth;
                canvas.height = newHeight;
                updateDimensions(); // Update dimensions before drawing
                draw(); // Redraw content after resizing
            }

            // Initial resize and add event listener for window resize
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to set initial size

            // Function to simulate keyboard events for mobile controls
            function simulateKeyEvent(key, type) {
                const event = new KeyboardEvent(type, {
                    key: key,
                    code: key,
                    bubbles: true,
                    cancelable: true
                });
                document.dispatchEvent(event);
            }

            // Function to simulate multiple key events for diagonal controls
            function simulateMultiKeyEvents(keysArray, type) {
                keysArray.forEach(key => {
                    const event = new KeyboardEvent(type, {
                        key: key,
                        code: key,
                        bubbles: true,
                        cancelable: true
                    });
                    document.dispatchEvent(event);
                });
            }

            // Event listener for key presses (keyboard and simulated)
            document.addEventListener('keydown', e => {
                const lowerCaseKey = e.key.toLowerCase();
                keys[lowerCaseKey] = true; // Mark key as pressed
                // console.log("Keydown:", lowerCaseKey, "Current keys:", { ...keys }); // Debugging log

                // Handle spacebar for game start/reset
                if (lowerCaseKey === ' ') {
                    if (gameState === 'idle') {
                        startCountdown(); // Start countdown if idle
                    } else if (gameState === 'running' || gameState === 'finished') { // Allow reset from running or finished
                        resetGame(); // Reset game if running or finished
                    }
                }

                // Manual mode tapping logic (only if game is running)
                if (gameState === 'running' && manualModeCheckbox.checked) {
                    const now = performance.now();
                    const tapCurveExponent = parseFloat(tapCurveExponentSelect.value);

                    if (lowerCaseKey === 'z' && leftTapState === 0) {
                        leftTapState = 1;
                        const delta = now - lastLeftTapTime;
                        lastLeftTapTime = now;
                        if (delta > 0 && delta < 1000) {
                            currentLeftSpeed = Math.min(getSpeed(), Math.pow(1000 / delta, tapCurveExponent) * parseFloat(manualSpeedMultiplierSelect.value));
                        }
                    } else if (lowerCaseKey === 'x' && leftTapState === 1) {
                        leftTapState = 0;
                        const delta = now - lastLeftTapTime;
                        lastLeftTapTime = now;
                        if (delta > 0 && delta < 1000) {
                            currentLeftSpeed = Math.min(getSpeed(), Math.pow(1000 / delta, tapCurveExponent) * parseFloat(manualSpeedMultiplierSelect.value));
                        }
                    }

                    if (lowerCaseKey === 'c' && rightTapState === 0) {
                        rightTapState = 1;
                        const delta = now - lastRightTapTime;
                        lastRightTapTime = now;
                        if (delta > 0 && delta < 1000) {
                            currentRightSpeed = Math.min(getSpeed(), Math.pow(1000 / delta, tapCurveExponent) * parseFloat(manualSpeedMultiplierSelect.value));
                        }
                    } else if (lowerCaseKey === 'v' && rightTapState === 1) {
                        rightTapState = 0;
                        const delta = now - lastRightTapTime;
                        lastRightTapTime = now;
                        if (delta > 0 && delta < 1000) {
                            currentRightSpeed = Math.min(getSpeed(), Math.pow(1000 / delta, tapCurveExponent) * parseFloat(manualSpeedMultiplierSelect.value));
                        }
                    }
                }
            });

            // Event listener for key releases (keyboard and simulated)
            document.addEventListener('keyup', e => {
                const lowerCaseKey = e.key.toLowerCase();
                keys[lowerCaseKey] = false; // Mark key as released
                // console.log("Keyup:", lowerCaseKey, "Current keys:", { ...keys }); // Debugging log
            });

            // Add touch and mouse event listeners for D-pad controls
            const directionalButtons = [
                { button: leftBtn, key: 'a' },
                { button: rightBtn, key: 'd' },
                { button: upBtn, key: 'w' },
                { button: downBtn, key: 's' }
            ];

            directionalButtons.forEach(({ button, key }) => {
                button.addEventListener('touchstart', (e) => { e.preventDefault(); simulateKeyEvent(key, 'keydown'); });
                button.addEventListener('touchend', (e) => { e.preventDefault(); simulateKeyEvent(key, 'keyup'); });
                button.addEventListener('mousedown', (e) => { e.preventDefault(); simulateKeyEvent(key, 'keydown'); });
                button.addEventListener('mouseup', (e) => { e.preventDefault(); simulateKeyEvent(key, 'keyup'); });
                button.addEventListener('mouseleave', (e) => {
                    // Only simulate keyup if the mouse button was still down when leaving the element
                    if (e.buttons === 1) { simulateKeyEvent(key, 'keyup'); }
                });
            });

            // Add touch and mouse event listeners for diagonal buttons
            const diagonalButtons = [
                { button: upRightBtn, keys: ['w', 'd'] },
                { button: downRightBtn, keys: ['d', 's'] },
                { button: downLeftBtn, keys: ['a', 's'] },
                { button: upLeftBtn, keys: ['a', 'w'] }
            ];

            diagonalButtons.forEach(({ button, keys }) => {
                button.addEventListener('touchstart', (e) => { e.preventDefault(); simulateMultiKeyEvents(keys, 'keydown'); });
                button.addEventListener('touchend', (e) => { e.preventDefault(); simulateMultiKeyEvents(keys, 'keyup'); });
                button.addEventListener('mousedown', (e) => { e.preventDefault(); simulateMultiKeyEvents(keys, 'keydown'); });
                button.addEventListener('mouseup', (e) => { e.preventDefault(); simulateMultiKeyEvents(keys, 'keyup'); });
                button.addEventListener('mouseleave', (e) => {
                    // Only simulate keyup if the mouse button was still down when leaving the element
                    if (e.buttons === 1) { simulateMultiKeyEvents(keys, 'keyup'); }
                });
            });


            // Function to get the current speed from the slider
            function getSpeed() {
                return parseFloat(speedSelect.value);
            }

            // Function to determine the next blink time for the stickman
            function getNextBlinkTime() {
                return performance.now() + 3000 + Math.random() * 2000; // Blink every 3-5 seconds
            }

            // Function to load high scores from local storage
            function loadHighScores() {
                const storedScores = localStorage.getItem(HIGHSCORE_STORAGE_KEY);
                highScores = storedScores ? JSON.parse(storedScores) : [];
                // Ensure scores are sorted and trimmed to MAX_HIGH_SCORES
                highScores.sort((a, b) => a - b);
                highScores = highScores.slice(0, MAX_HIGH_SCORES);
            }

            // Function to save high scores to local storage
            function saveHighScores() {
                localStorage.setItem(HIGHSCORE_STORAGE_KEY, JSON.stringify(highScores));
            }

            // Function to add a new score to high scores
            function addScore(newScore) {
                highScores.push(newScore);
                highScores.sort((a, b) => a - b); // Sort ascending
                highScores = highScores.slice(0, MAX_HIGH_SCORES); // Keep only top MAX_HIGH_SCORES
                saveHighScores();
            }

            // Main update function for animation logic
            function update() {
                const now = performance.now(); // Get current time once per update

                // Declare stickmanBottomY here so it's accessible throughout update()
                let stickmanBottomY = 0; // Initialize to 0 as a default

                // Handle speed penalty (applies regardless of game state if active)
                let effectiveSpeedMultiplier = 1;
                if (speedPenaltyActive && now < speedPenaltyEndTime) {
                    effectiveSpeedMultiplier = 0.5; // 50% speed drop
                } else if (speedPenaltyActive && now >= speedPenaltyEndTime) {
                    speedPenaltyActive = false; // Penalty duration over
                }

                let desiredVx = 0; // Desired horizontal velocity
                const manualMode = manualModeCheckbox.checked;

                // --- Movement Logic (applies whether running or finished, based on input) ---
                if (gameState === 'running' || gameState === 'finished') { // Only allow movement if game is running or finished
                    if (!manualMode) {
                        if (keys['a']) {
                            desiredVx -= getSpeed();
                            dir = -1;
                        }
                        if (keys['d']) {
                            desiredVx += getSpeed();
                            dir = 1;
                        }
                    } else {
                        if (now - lastLeftTapTime > 500) currentLeftSpeed = 0;
                        if (now - lastRightTapTime > 500) currentRightSpeed = 0;
                        desiredVx = currentRightSpeed - currentLeftSpeed;
                        if (desiredVx !== 0) dir = desiredVx > 0 ? 1 : -1;
                        desiredVx = Math.sign(desiredVx) * Math.min(Math.abs(desiredVx), getSpeed());
                    }
                }

                // Apply effective speed multiplier (including penalty)
                desiredVx *= effectiveSpeedMultiplier;

                // Calculate current step frequency based on direction
                const currentStepFrequency = (dir === 1) ? parseFloat(document.getElementById('stepFrequency').value) : parseFloat(document.getElementById('stepFrequencyLeft').value);

                // Calculate the maximum allowed velocity based on the stride limit and step frequency
                const maxVxForStrideLimit = (currentStepFrequency > 0) ? (MAX_STEPCYCLE_ADVANCE_PER_FRAME / currentStepFrequency) : Infinity;

                // Apply the velocity cap
                let actualVx = desiredVx;
                if (Math.abs(desiredVx) > maxVxForStrideLimit) {
                    actualVx = Math.sign(desiredVx) * maxVxForStrideLimit;
                }

                // Update position (runner always moves if input is given and game state allows)
                position += actualVx;

                // Crouching, Jumping, Gravity (always applies if game is running or finished)
                if (gameState === 'running' || gameState === 'finished') {
                    isCrouching = keys['s'] && onGround;
                    vy += 0.6;
                    y += vy;

                    // Scale leg and foot lengths for consistent physics calculations
                    const scaledUpperLegLen = upperLegLen * (canvas.height / 400);
                    const scaledLowerLegLen = lowerLegLen * (canvas.height / 400);
                    const scaledFootRadius = footRadius * (canvas.height / 400);

                    // Assign stickmanBottomY here using scaled values
                    stickmanBottomY = y + scaledUpperLegLen + scaledLowerLegLen + scaledFootRadius;
                    
                    if (stickmanBottomY >= stickmanGroundY) {
                        // Corrected calculation for y using scaled values
                        y = stickmanGroundY - (scaledUpperLegLen + scaledLowerLegLen + scaledFootRadius);
                        vy = 0;
                        onGround = true;
                        isHurling = false;
                    } else {
                        onGround = false;
                    }

                    if (isHurling) {
                        isCrouching = false;
                    }

                    if (keys['w'] && onGround) {
                        vy = -10;
                        onGround = false;
                        if (keys['a'] || keys['d']) {
                            isHurling = true;
                        }
                    }

                    // Advance step cycle only if moving on ground
                    if (onGround && actualVx !== 0) {
                        const desiredStepAdvance = Math.abs(actualVx) * currentStepFrequency;
                        stepCycle += desiredStepAdvance;
                    } else if (!onGround) {
                        // Keep step cycle from advancing when in air, but don't reset it to 0
                    } else { // On ground but not moving
                        stepCycle = 0; // Reset step cycle for idle pose
                    }
                }


                // --- Game State Specific Logic ---
                // Declare stickmanGlobalMeterPosition once here
                const stickmanGlobalMeterPosition = position / pixelsPerMeter;

                if (gameState === 'running') {
                    // Hurdle cleared/collision detection (only when running)
                    hurdles.forEach((hurdle, index) => {
                        const hurdleCenterGlobalX = hurdle.meterPosition * pixelsPerMeter;
                        const hurdleRenderX = hurdleCenterGlobalX - position + (canvas.width / 2);

                        const lane2TopY = groundY + (stickmanLane - 1) * laneHeight;
                        const lane2BottomY = groundY + stickmanLane * laneHeight;

                        const uprightHurdleHeight = 40 * (canvas.height / 400);
                        const hurdleVisualWidthAcrossLane = laneHeight;

                        const hurdleCollisionTop = lane2BottomY - uprightHurdleHeight;
                        const hurdleCollisionBottom = lane2BottomY;

                        const hurdleCollisionLeft = hurdleRenderX - hurdleVisualWidthAcrossLane / 2;
                        const hurdleCollisionRight = hurdleRenderX + hurdleVisualWidthAcrossLane / 2;

                        const stickmanBodyWidth = 10 * (canvas.width / 600);
                        const stickmanLeftX = canvas.width / 2 - stickmanBodyWidth / 2;
                        const stickmanRightX = canvas.width / 2 + stickmanBodyWidth / 2;
                        const stickmanHeadY = y - (10 + 5) * (canvas.height / 400);
                        const stickmanFootY = stickmanBottomY;

                        const horizontalOverlap = (stickmanRightX > hurdleCollisionLeft && stickmanLeftX < hurdleCollisionRight);
                        const verticalOverlap = (stickmanFootY > hurdleCollisionTop && stickmanHeadY < hurdleCollisionBottom);

                        // Check for collision
                        if (horizontalOverlap && verticalOverlap && !isHurling && !hurdle.isFallen) {
                            hurdle.isFallen = true;
                            speedPenaltyActive = true;
                            speedPenaltyEndTime = now + 1000;
                            console.log("Hurdle hit! Playing aww sound and collision sound.");
                            if (awwPlayer.loaded) {
                                awwPlayer.start(); // Play the "aww" sound
                            } else {
                                console.warn("Aww sound not loaded yet.");
                            }
                            hurdleSynth.triggerAttackRelease('C3', '0.1', Tone.now(), 1.0); // Play original collision sound
                            hurdlesClearedCount = 0; // Reset count on hit
                            console.log('Hurdle was hit, hurdlesClearedCount reset to 0.');
                        }

                        // Check for successful clear (if stickman has passed the hurdle and it's not fallen)
                        // This condition ensures we only count a hurdle once and only if it wasn't hit
                        if (stickmanGlobalMeterPosition * pixelsPerMeter > hurdleCenterGlobalX + (hurdleVisualWidthAcrossLane / 2) && index > lastHurdleIndexPassed) {
                            if (!hurdle.isFallen) {
                                hurdlesClearedCount++;
                                console.log('Hurdle successfully cleared! Current hurdlesClearedCount:', hurdlesClearedCount);

                                // Play "oh yeah" for hurdle 3 (index 2) or hurdle 4 (index 3)
                                if (index === 2 && !hurdle3Cleared) { // Hurdle 3 is at index 2
                                    if (ohYeahPlayer.loaded && Tone.context.state === 'running') {
                                        ohYeahPlayer.start();
                                        console.log("Played 'Oh Yeah!' sound for hurdle 3.");
                                    } else {
                                        console.warn("'Oh Yeah!' sound not loaded or audio context not running for hurdle 3.");
                                    }
                                    hurdle3Cleared = true; // Mark as played
                                } else if (index === 3 && !hurdle4Cleared) { // Hurdle 4 is at index 3
                                    if (ohYeahPlayer.loaded && Tone.context.state === 'running') {
                                        ohYeahPlayer.start();
                                        console.log("Played 'Oh Yeah!' sound for hurdle 4.");
                                    } else {
                                        console.warn("'Oh Yeah!' sound not loaded or audio context not running for hurdle 4.");
                                    }
                                    hurdle4Cleared = true; // Mark as played
                                }
                            }
                            lastHurdleIndexPassed = index; // Update the last passed hurdle index
                            
                            // Check for 8 cleared hurdles
                            if (hurdlesClearedCount >= 8) {
                                if (hellYeahPlayer.loaded && Tone.context.state === 'running') {
                                    hellYeahPlayer.start();
                                    console.log("Played 'Hell Yeah!' sound for 8 clears.");
                                } else {
                                    console.warn("'Hell Yeah!' sound not loaded or audio context not running.");
                                }
                                hurdlesClearedCount = 0; // Reset after playing to prevent repeated playback
                                console.log("hurdlesClearedCount reset to 0 after playing 'Hell Yeah!'.");
                            }
                        }
                    });

                    // Finish line detection
                    if (stickmanGlobalMeterPosition >= finishLineMeter) {
                        gameState = 'finished';
                        finalTime = now - startTime; // Record final time
                        addScore(finalTime); // Add to high scores
                        console.log("Race finished! Final Time:", formatTime(finalTime));
                    }

                    // Crowd sound logic: Start at 60m
                    if (stickmanGlobalMeterPosition >= 60) {
                        if (!isCrowdSoundActive && crowdPlayer.loaded && Tone.context.state === 'running') {
                            crowdPlayer.volume.value = -5; // Set to audible level
                            crowdPlayer.start();
                            isCrowdSoundActive = true;
                            console.log("Crowd player STARTED at 60m mark. Volume:", crowdPlayer.volume.value);
                        } else if (isCrowdSoundActive) {
                            // Once active, maintain volume
                            crowdPlayer.volume.value = -5;
                        }
                    } else {
                        // Before 60m, ensure crowd is stopped and muted
                        if (isCrowdSoundActive) {
                            try {
                                crowdPlayer.stop();
                                isCrowdSoundActive = false;
                                console.log("Crowd player STOPPED (before 60m mark).");
                            } catch (e) {
                                console.error("Error stopping crowd player before 60m:", e);
                            }
                        }
                        crowdPlayer.volume.value = -Infinity; // Ensure muted
                    }


                } else if (gameState === 'finished') {
                    // Runner continues to move, so no special "stop" logic here for runner movement.
                    // Keep cheering loud after finishing.
                    crowdPlayer.volume.value = -5; // Full volume for cheering
                    if (!isCrowdSoundActive && crowdPlayer.loaded && Tone.context.state === 'running') {
                        try {
                            crowdPlayer.start();
                            isCrowdSoundActive = true;
                            console.log("Crowd player STARTED in FINISHED state. Volume:", crowdPlayer.volume.value);
                        } catch (e) {
                            console.error("Error starting crowd player in FINISHED state:", e);
                        }
                    }


                } else { // Idle or countdown
                    // If not running, ensure stickman is idle
                    stepCycle = 0;
                    isCrouching = false;
                    isHurling = false;
                    const maxLegHeight = upperLegLen + lowerLegLen + footRadius;
                    y = stickmanGroundY - maxLegHeight * (canvas.height / 400);
                    vy = 0;
                    onGround = true;

                    // Stop crowd sound when not running or finished
                    if (isCrowdSoundActive) { // Only stop if it was active
                        try {
                            crowdPlayer.stop();
                            isCrowdSoundActive = false; // Set flag to false
                            console.log("Crowd player STOPPED in IDLE/COUNTDOWN state.");
                        } catch (e) {
                            console.error("Error stopping crowd player:", e);
                        }
                    }
                    crowdPlayer.volume.value = -Infinity; // Ensure muted
                }

                // Handle eye blinking animation (always active)
                if (!isBlinking && now > nextBlinkTime) {
                    isBlinking = true;
                    blinkTimer = now + 150;
                }
                if (isBlinking && now > blinkTimer) {
                    isBlinking = false;
                    nextBlinkTime = getNextBlinkTime();
                }
            }

            // Function to format milliseconds into MM:SS.CC format
            function formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const centiseconds = Math.floor((milliseconds % 1000) / 10);

                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
            }

            // This function now draws the stopwatch directly on the canvas
            function drawStopwatch() {
                let timeToDisplay = '00:00.00';
                if (gameState === 'running') {
                    const elapsedTime = performance.now() - startTime;
                    timeToDisplay = formatTime(elapsedTime);
                } else if (gameState === 'finished') {
                    timeToDisplay = formatTime(finalTime); // Display final time if finished
                }

                ctx.save();
                ctx.fillStyle = 'black'; // Text color for stopwatch
                // Scale font size based on canvas width
                ctx.font = `${24 * (canvas.width / 600)}px 'Fira Code', monospace`;
                ctx.textAlign = 'right'; // Align text to the right
                ctx.textBaseline = 'top'; // Align text to the top

                // Position in the top right corner with some padding, scaled
                const padding = 10 * (canvas.width / 600);
                ctx.fillText(timeToDisplay, canvas.width - padding, padding);
                ctx.restore();
            }

            // New function to draw high scores on the canvas
            function drawHighScores() {
                ctx.save();
                ctx.fillStyle = 'black';
                ctx.font = `${16 * (canvas.width / 600)}px 'Fira Code', monospace`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                const padding = 10 * (canvas.width / 600);
                let yOffset = padding;

                ctx.fillText('Top Times:', padding, yOffset);
                yOffset += 20 * (canvas.width / 600);

                if (highScores.length === 0) {
                    ctx.fillText('N/A', padding, yOffset);
                } else {
                    highScores.forEach((score, index) => {
                        ctx.fillText(`${index + 1}. ${formatTime(score)}`, padding, yOffset);
                        yOffset += 20 * (canvas.width / 600);
                    });
                }
                ctx.restore();
            }

            // New function to draw the countdown message on the canvas
            function drawCountdownMessage() {
                const now = performance.now();
                if (currentCountdownMessage && now < countdownMessageEndTime) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'; // Darker text for visibility
                    // Scale font size
                    ctx.font = `${60 * (canvas.width / 600)}px Arial Black`; // Large, bold font
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Calculate opacity for fade-out effect
                    const fadeDuration = 300; // milliseconds
                    const remainingTime = countdownMessageEndTime - now;
                    let opacity = 1;
                    if (remainingTime < fadeDuration) {
                        opacity = remainingTime / fadeDuration;
                    }
                    ctx.globalAlpha = opacity;

                    ctx.fillText(currentCountdownMessage, canvas.width / 2, canvas.height / 2);
                    ctx.restore();
                }
            }

            // Function to display a countdown message and play a sound
            function showCountdownMessage(message, duration = 500) {
                currentCountdownMessage = message;
                countdownMessageEndTime = performance.now() + duration;

                // Play sound based on the message
                if (beepFrequencies[message]) {
                    mainSynth.triggerAttackRelease(beepFrequencies[message], '8n'); // Play the note for an 8th note duration
                }
            }

            // Function to start the game countdown
            async function startCountdown() { // Made async to await Tone.start()
                // Ensure audio context is active on user gesture
                if (Tone.context.state !== 'running') {
                    try {
                        await Tone.start();
                        console.log("AudioContext resumed successfully by startCountdown.");
                    } catch (e) {
                        console.error("Failed to resume AudioContext:", e);
                        // Optionally, show a message to the user that audio couldn't start
                    }
                }

                gameState = 'countdown';
                actionButton.style.display = 'none'; // Hide action button during countdown
                showCountdownMessage('Ready!', 700);
                setTimeout(() => {
                    showCountdownMessage('Set!', 700);
                    setTimeout(() => {
                        showCountdownMessage('Go!', 700);
                        setTimeout(async () => { // Made this inner function async
                            gameState = 'running';
                            startTime = performance.now(); // Start stopwatch
                            currentCountdownMessage = ''; // Clear message after "Go!"
                            actionButton.style.display = 'block'; // Show button after countdown
                            actionButton.textContent = 'Reset'; // Change button text to Reset

                            // No crowd sound start here, it will be handled in update() based on position
                        }, 700);
                    }, 1000); // Delay before "Set!"
                }, 1000); // Delay before "Ready!"
            }

            // Function to reset the game to its initial idle state
            function resetGame() {
                gameState = 'idle';
                position = initialRunnerOffsetMeters * pixelsPerMeter; // Set initial position based on offset
                startTime = 0;
                finalTime = 0; // Reset final time
                currentCountdownMessage = ''; // Clear any active countdown message
                countdownMessageEndTime = 0;
                keys = {}; // Clear all pressed keys
                currentLeftSpeed = 0; // Reset manual speeds
                currentRightSpeed = 0;
                dir = 1; // Reset direction to right
                stepCycle = 0; // Reset animation cycle
                isHurling = false; // Reset hurdling state
                speedPenaltyActive = false; // Reset speed penalty
                speedPenaltyEndTime = 0;

                // Reset all hurdles to upright
                hurdles.forEach(hurdle => {
                    hurdle.isFallen = false;
                });

                // Reset hurdle cleared count and index
                hurdlesClearedCount = 0;
                lastHurdleIndexPassed = -1;
                hurdle3Cleared = false; // Reset hurdle 3 cleared flag
                hurdle4Cleared = false; // Reset hurdle 4 cleared flag

                // Ensure stickman is in idle pose at the correct ground level
                const maxLegHeight = upperLegLen + lowerLegLen + footRadius;
                y = stickmanGroundY - maxLegHeight * (canvas.height / 400); // Set y for idle pose
                vy = 0;
                onGround = true;
                actionButton.style.display = 'block'; // Show action button
                actionButton.textContent = 'Start'; // Change button text to Start

                // Stop crowd sound when not running
                if (isCrowdSoundActive) { // Only stop if it was active
                    try {
                        crowdPlayer.stop();
                        isCrowdSoundActive = false; // Set flag to false
                        console.log("Crowd player STOPPED during reset.");
                    } catch (e) {
                        console.error("Error stopping crowd player:", e);
                    }
                }
                crowdPlayer.volume.value = -Infinity; // Ensure muted
            }

            // Function to draw clouds with parallax effect
            function drawClouds() {
                ctx.save();
                ctx.fillStyle = 'white';
                clouds.forEach(cloud => {
                    // Calculate cloud's x position relative to the canvas, with parallax
                    let renderX = cloud.initialX - (position * cloud.parallaxFactor);

                    // Wrap around the canvas width to create continuous scrolling
                    renderX = renderX % canvas.width;
                    if (renderX < -cloud.width * (canvas.width / 600)) { // If it goes off left, bring it to the right
                        renderX += canvas.width + cloud.width * (canvas.width / 600);
                    } else if (renderX > canvas.width) { // If it goes off right, bring it to the left (shouldn't happen with positive position)
                        renderX -= canvas.width + cloud.width * (canvas.width / 600);
                    }

                    // Scale cloud dimensions and y position
                    const scaledWidth = cloud.width * (canvas.width / 600);
                    const scaledHeight = cloud.height * (canvas.height / 400);
                    const scaledY = cloud.y * (canvas.height / 400);

                    // Draw simple cloud shape using multiple circles
                    ctx.beginPath();
                    ctx.arc(renderX, scaledY, scaledWidth / 3, 0, Math.PI * 2);
                    ctx.arc(renderX + scaledWidth * 0.4, scaledY - scaledHeight * 0.3, scaledWidth / 3, 0, Math.PI * 2);
                    ctx.arc(renderX + scaledWidth * 0.7, scaledY, scaledWidth / 3, 0, Math.PI * 2);
                    ctx.arc(renderX + scaledWidth * 0.3, scaledY + scaledHeight * 0.3, scaledWidth / 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
            }

            function drawGround() {
                ctx.fillStyle = '#87CEEB'; // Light blue sky
                ctx.fillRect(0, 0, canvas.width, groundY);

                drawClouds(); // Draw clouds after sky is painted

                ctx.fillStyle = '#228B22'; // Forest green grass
                ctx.fillRect(0, groundY - 50 * (canvas.height / 400), canvas.width, 50 * (canvas.height / 400));

                ctx.fillStyle = '#c1440e'; // Brick red for track
                ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;

                for (let i = 0; i <= numLanes; i++) {
                    const y = groundY + i * laneHeight;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                const interval = 100 * (canvas.width / 600);
                const dashLength = 5 * (canvas.height / 400);
                const offset = position % interval;
                const pixelsPerMeter = 50 * (canvas.width / 600);

                for (let xi = -interval; xi < canvas.width + interval; xi += interval) {
                    const draw_x = xi - offset;
                    ctx.beginPath();
                    ctx.moveTo(draw_x, stickmanGroundY - dashLength / 2);
                    ctx.lineTo(draw_x, stickmanGroundY + dashLength / 2);
                    ctx.stroke();

                    const relative = draw_x - canvas.width / 2;
                    const meter = Math.round((position + relative) / pixelsPerMeter);
                    if (meter % 10 === 0 && meter >= 0 && meter <= 100) {
                        ctx.fillStyle = 'white';
                        ctx.fillRect(draw_x - 15 * (canvas.width / 600), groundY - 25 * (canvas.height / 400), 30 * (canvas.width / 600), 15 * (canvas.height / 400));
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(meter + 'm', draw_x, groundY - 17.5 * (canvas.height / 400));
                    }

                    if (meter === 0) {
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(draw_x, groundY);
                        ctx.lineTo(draw_x, canvas.height);
                        ctx.stroke();
                        ctx.lineWidth = 2;
                        ctx.fillStyle = 'white';
                        ctx.fillRect(draw_x - 35 * (canvas.width / 600), groundY - 25 * (canvas.height / 400), 70 * (canvas.width / 600), 15 * (canvas.height / 400));
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Start', draw_x, groundY - 17.5 * (canvas.height / 400));

                        for (let i = 1; i <= numLanes; i++) {
                            ctx.save();
                            ctx.translate(draw_x - 10 * (canvas.width / 600), groundY + (i - 0.5) * laneHeight);
                            ctx.rotate(Math.PI / 2);
                            ctx.fillStyle = 'white';
                            ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(i, 0, 0);
                            ctx.restore();
                        }
                    }

                    if (meter === 100) {
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(draw_x, groundY);
                        ctx.lineTo(draw_x, canvas.height);
                        ctx.stroke();
                        ctx.lineWidth = 2;
                        ctx.fillStyle = 'white';
                        ctx.fillRect(draw_x - 35 * (canvas.width / 600), groundY - 25 * (canvas.height / 400), 70 * (canvas.width / 600), 15 * (canvas.height / 400));
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Finish', draw_x, groundY - 17.5 * (canvas.height / 400));
                    }
                }
            }

            // New function to draw hurdles
            function drawHurdles() {
                ctx.save();
                ctx.lineWidth = 1 * (canvas.width / 600); // Scaled line width

                // Define hurdle dimensions once, scaled
                const baseHurdleHeight = 40; // Base height in original canvas units
                const baseHurdleThickness = 2; // Base thickness along track in original canvas units (for fallen hurdle width)
                const baseHurdleBarThickness = 5; // Base yellow bar thickness in original canvas units

                const uprightHurdleHeight = baseHurdleHeight * (canvas.height / 400);
                const hurdleDepthAlongTrack = baseHurdleThickness * (canvas.width / 600);
                const hurdleBarThickness = baseHurdleBarThickness * (canvas.height / 400);
                // Hurdle spans the full width of the lane visually
                const hurdleVisualWidthAcrossLane = laneHeight;

                hurdles.forEach(hurdle => {
                    const hurdleCenterGlobalX = hurdle.meterPosition * pixelsPerMeter;
                    // Calculate hurdleRenderX relative to the stickman's position
                    let hurdleRenderX = hurdleCenterGlobalX - position + (canvas.width / 2);

                    // Lane 2 boundaries (where the hurdles are always located)
                    const lane2TopY = groundY + (stickmanLane - 1) * laneHeight;
                    const lane2BottomY = groundY + stickmanLane * laneHeight;

                    if (hurdle.isFallen) {
                        // When fallen, the hurdle lies flat horizontally within Lane 2.
                        // Its length along the track is its original upright height.
                        // Its thickness across the lane is its original depth along the track.

                        const fallenHurdleLengthAlongTrack = uprightHurdleHeight;
                        const fallenHurdleWidthAcrossLane = hurdleDepthAlongTrack;

                        // Position the fallen hurdle to be centered vertically within Lane 2
                        const fallenHurdleCenterY = lane2TopY + (laneHeight / 2);
                        const fallenHurdleDrawY = fallenHurdleCenterY - (fallenHurdleWidthAcrossLane / 2);

                        // Adjust X position based on runner's direction when fallen
                        // If dir is 1 (right), shift slightly right. If dir is -1 (left), shift slightly left.
                        const fallOffset = (dir * fallenHurdleLengthAlongTrack * 0.2); // Small offset to show direction
                        const fallenHurdleXStart = hurdleRenderX - fallenHurdleLengthAlongTrack / 2 + fallOffset;

                        // Draw the yellow top bar
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(
                            fallenHurdleXStart,
                            fallenHurdleDrawY,
                            fallenHurdleLengthAlongTrack,
                            hurdleBarThickness
                        );
                        ctx.strokeRect(
                            fallenHurdleXStart,
                            fallenHurdleDrawY,
                            fallenHurdleLengthAlongTrack,
                            hurdleBarThickness
                        );

                        // Draw the white main body
                        ctx.fillStyle = 'white';
                        ctx.fillRect(
                            fallenHurdleXStart,
                            fallenHurdleDrawY + hurdleBarThickness,
                            fallenHurdleLengthAlongTrack,
                            fallenHurdleWidthAcrossLane - hurdleBarThickness
                        );
                        ctx.strokeRect(
                            fallenHurdleXStart,
                            fallenHurdleDrawY + hurdleBarThickness,
                            fallenHurdleLengthAlongTrack,
                            fallenHurdleWidthAcrossLane - hurdleBarThickness
                        );

                    } else {
                        // Draw the upright hurdle.
                        // It stands across Lane 2, with its base on Line 3, extending upwards into Lane 2.

                        // The bottom of the upright hurdle aligns with lane2BottomY (Line 3)
                        const uprightHurdleDrawY = lane2BottomY - uprightHurdleHeight;

                        // Draw the white main body (legs and support structure)
                        ctx.fillStyle = 'white';
                        ctx.fillRect(
                            hurdleRenderX - hurdleVisualWidthAcrossLane / 2, // X start (centered across the lane)
                            uprightHurdleDrawY + hurdleBarThickness, // Y start (below top bar)
                            hurdleVisualWidthAcrossLane, // Width (spans the lane)
                            uprightHurdleHeight - hurdleBarThickness // Height (rest of hurdle height)
                        );
                        ctx.strokeRect(
                            hurdleRenderX - hurdleVisualWidthAcrossLane / 2,
                            uprightHurdleDrawY + hurdleBarThickness,
                            hurdleVisualWidthAcrossLane,
                            uprightHurdleHeight - hurdleBarThickness
                        );

                        // Draw the yellow top bar
                        ctx.fillStyle = 'yellow';
                        ctx.fillRect(
                            hurdleRenderX - hurdleVisualWidthAcrossLane / 2, // X start (centered across the lane)
                            uprightHurdleDrawY, // Y start (top of hurdle)
                            hurdleVisualWidthAcrossLane, // Width (spans the lane)
                            hurdleBarThickness // Height (thickness of the bar)
                        );
                        ctx.strokeRect(
                            hurdleRenderX - hurdleVisualWidthAcrossLane / 2,
                            uprightHurdleDrawY,
                            hurdleVisualWidthAcrossLane,
                            hurdleBarThickness
                        );
                    }
                });
                ctx.restore();
            }

            function drawStickman() {
                ctx.lineWidth = 2 * (canvas.width / 600); // Scale line width
                ctx.strokeStyle = '#000';
                ctx.save();

                const moving = (gameState === 'running' || gameState === 'finished') && ((keys['a'] || keys['d']) || currentLeftSpeed > 0 || currentRightSpeed > 0);

                const gaitAmplitude = (dir === 1) ? parseFloat(document.getElementById('gaitAmplitude').value) : parseFloat(document.getElementById('gaitAmplitudeLeft').value);
                const stepFrequency = (dir === 1) ? parseFloat(document.getElementById('stepFrequency').value) : parseFloat(document.getElementById('stepFrequencyLeft').value);
                const frontKneeBend = (dir === 1) ? parseFloat(document.getElementById('frontKneeBend').value) : parseFloat(document.getElementById('frontKneeBendLeft').value);
                const backKneeBendMax = (dir === 1) ? parseFloat(document.getElementById('backKneeBendMax').value) : parseFloat(document.getElementById('backKneeBendMaxLeft').value);
                const backKneeBendMultiplier = (dir === 1) ? parseFloat(document.getElementById('backKneeBendMultiplier').value) : parseFloat(document.getElementById('backKneeBendMultiplierLeft').value);
                const elbowBend = (dir === 1) ? parseFloat(document.getElementById('elbowBend').value) : parseFloat(document.getElementById('elbowBendLeft').value);
                const torsoThickness = (dir === 1) ? parseFloat(document.getElementById('torsoThickness').value) : parseFloat(document.getElementById('torsoThicknessLeft').value);
                const armSwingMultiplier = (dir === 1) ? parseFloat(armSwingMultiplierSelect.value) : parseFloat(armSwingMultiplierLeftSelect.value);


                const crouchExtraBend = parseFloat(document.getElementById('crouchExtraBend').value);

                // Legs
                const phase = ((stepCycle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                
                let currentLegAngles = [0, 0];
                let currentKneeBends = [0, 0];
                let currentArmAngles = [0, 0]; // For drawArm
                let currentElbowBends = [0, 0]; // For drawArm
                let currentLeftHandTarget = null; // For drawArmToHand
                let currentRightHandTarget = null; // For drawArmToHand
                let useDrawArmToHand = false; // Flag to decide which arm drawing function to use

                let crouchDrawOffset = 0; // Initialize offset for drawing


                // Get hurdle knee bend values from sliders
                const hurdleLeadKneeBend = parseFloat(hurdleLeadKneeBendSelect.value);
                const hurdleTrailKneeBend = parseFloat(hurdleTrailKneeBendSelect.value);

                if (isCrouching) {
                    // When crouching, override leg and knee angles for a squat pose
                    const squatUpperLegAngle = Math.PI / 4; // More outward angle for upper legs
                    const squatKneeBend = 2.0; // Deeper knee bend for squat

                    currentLegAngles = [squatUpperLegAngle, -squatUpperLegAngle]; // Left leg outward, Right leg outward
                    currentKneeBends = [squatKneeBend, squatKneeBend]; // Symmetrical deep bend

                    crouchDrawOffset = crouchExtraBend * 30 * (canvas.height / 400); // Lower the body significantly
                } else if (isHurling) { // New hurdle pose logic
                    // Adjust leg angles for hurdling
                    const hurdleLeadLegAngle = -Math.PI / 6; // Lead leg forward and slightly down
                    const hurdleTrailLegAngle = Math.PI / 2; // Trail leg bent and raised high

                    if (dir === 1) { // Moving right, left leg leads
                        currentLegAngles = [hurdleLeadLegAngle, hurdleTrailLegAngle];
                        currentKneeBends = [hurdleLeadKneeBend, hurdleTrailKneeBend];
                    } else { // Moving left, right leg leads
                        currentLegAngles = [hurdleTrailLegAngle, hurdleLeadLegAngle];
                        currentKneeBends = [hurdleTrailKneeBend, hurdleLeadKneeBend];
                    }
                }
                else if (moving && onGround) {
                    currentLegAngles = [
                        Math.sin(phase) * gaitAmplitude,
                        Math.sin(phase + Math.PI) * gaitAmplitude
                    ];
                    currentKneeBends = currentLegAngles.map(a => {
                        const isBack = (a < 0);
                        return isBack ? Math.min(backKneeBendMax, -a * backKneeBendMultiplier) : frontKneeBend;
                    });
                } else if (gameState === 'idle' || gameState === 'countdown') { // Apply ready pose for idle and countdown
                    // Ensure facing right
                    dir = 1;

                    // Legs: One forward, one back, both bent
                    currentLegAngles = [-Math.PI / 8, Math.PI / 8]; // Front leg slightly back, back leg slightly forward
                    currentKneeBends = [0.5, 0.5]; // Both knees slightly bent
                } else if (gameState === 'finished' || (!moving && gameState === 'running')) { // Normal idle pose for finished state OR stopped mid-race
                    // Always face right in this pose
                    dir = 1;
                    currentLegAngles = [0, 0]; // Legs straight down
                    currentKneeBends = [0.1, 0.1]; // Slight knee bend for relaxed stance
                }
                else { // Default legs (should mostly be covered by above, but as a fallback)
                    currentLegAngles = [0, 0];
                    currentKneeBends = [0, 0];
                }

                // Add slight bobbing when walking on ground, but not when crouching or jumping
                let bobbingOffset = 0;
                if (moving && onGround && !isCrouching && vy === 0) { // Only bob if moving, on ground, not crouching, and not jumping
                    bobbingOffset = Math.sin(phase) * 3 * (canvas.height / 400); // Scale bobbing
                }

                let x = canvas.width / 2;

                let flipped = dir === -1;
                if (flipped) {
                    ctx.translate(x, 0);
                    ctx.scale(-1, 1);
                    ctx.translate(-x, 0);
                }

                // Hip spread: Apply when not moving, crouching, or hurdling to ensure both legs are visible
                const hipSpread = (!moving && !isCrouching && !isHurling) ? 3 * (canvas.width / 600) : 0;

                // Apply crouchDrawOffset and bobbingOffset to all y-coordinates for drawing
                const currentHipY = y + crouchDrawOffset + bobbingOffset;
                const hipLeft = { x: x - hipSpread, y: currentHipY };
                const hipRight = { x: x + hipSpread, y: currentHipY };
                const shoulder = { x: x, y: currentHipY - 25 * (canvas.height / 400) };
                const shoulderLeft = { x: x - torsoThickness * (canvas.width / 600), y: currentHipY - 25 * (canvas.height / 400) };
                const shoulderRight = { x: x + torsoThickness * (canvas.width / 600), y: currentHipY - 25 * (canvas.height / 400) };
                const neckTopY = shoulder.y - 5 * (canvas.height / 400);

                // Draw hips
                ctx.beginPath();
                ctx.arc(hipLeft.x, hipLeft.y, 3 * (canvas.width / 600), 0, Math.PI * 2); // Scale hip radius
                ctx.fillStyle = '#000';
                ctx.fill();
                ctx.beginPath();
                ctx.arc(hipRight.x, hipRight.y, 3 * (canvas.width / 600), 0, Math.PI * 2); // Scale hip radius
                ctx.fill();

                // Draw shoulders
                ctx.beginPath();
                ctx.arc(shoulderLeft.x, shoulderLeft.y, 2.5 * (canvas.width / 600), 0, Math.PI * 2); // Scale shoulder radius
                ctx.fill();
                ctx.beginPath();
                ctx.arc(shoulderRight.x, shoulderRight.y, 2.5 * (canvas.width / 600), 0, Math.PI * 2); // Scale shoulder radius
                ctx.fill();

                // Neck
                ctx.beginPath();
                ctx.moveTo(x, shoulder.y);
                ctx.lineTo(x, neckTopY);
                ctx.stroke();

                // Head
                ctx.beginPath();
                ctx.arc(x, neckTopY - 10 * (canvas.height / 400), 10 * (canvas.width / 600), 0, Math.PI * 2); // Scale head radius
                ctx.fillStyle = '#D3D3D3'; // Light grey for face
                ctx.fill();
                ctx.strokeStyle = '#000';
                ctx.stroke();
                const faceDir = moving ? (flipped ? -dir : dir) : (gameState === 'idle' || gameState === 'countdown' || gameState === 'finished' || (!moving && gameState === 'running') ? 1 : 0); // Face right when idle or countdown
                drawFace(x, neckTopY - 10 * (canvas.height / 400), expressionSelect.value, faceDir);

                // Torso
                ctx.beginPath();
                ctx.moveTo(shoulderLeft.x, shoulder.y);
                ctx.lineTo(shoulderRight.x, shoulder.y);
                ctx.lineTo(x, currentHipY); // Use currentHipY for torso bottom
                ctx.lineTo(shoulderLeft.x, shoulder.y);
                ctx.stroke();

                // Draw legs
                drawLeg(hipLeft, upperLegLen * (canvas.height / 400), currentLegAngles[0], lowerLegLen * (canvas.height / 400), currentKneeBends[0]);
                drawLeg(hipRight, upperLegLen * (canvas.height / 400), currentLegAngles[1], lowerLegLen * (canvas.height / 400), currentKneeBends[1]);

                // Determine Arm Poses
                if (isHurling) { // Specific arm pose for hurdling
                    const hurdleArmForwardAngle = -Math.PI / 8; // Arm forward and slightly down
                    const hurdleArmBackwardAngle = Math.PI / 4; // Arm back and slightly up

                    const hurdleElbowBend = 0.5; // Slight bend in elbows

                    if (dir === 1) { // Moving right, left arm forward
                        currentArmAngles = [hurdleArmForwardAngle, hurdleArmBackwardAngle];
                        currentElbowBends = [hurdleElbowBend, hurdleElbowBend];
                    } else { // Moving left, right arm forward
                        currentArmAngles = [hurdleArmBackwardAngle, hurdleArmForwardAngle];
                        currentElbowBends = [hurdleElbowBend, hurdleElbowBend];
                    }
                    useDrawArmToHand = false; // Use drawArm
                }
                else if (moving && onGround && !isCrouching) { // Arm swing when walking
                    const armPhase = phase + Math.PI;
                    // Multiply arm swing by 'dir' to mirror the swing direction relative to the stickman's body
                    currentArmAngles = [
                        -Math.sin(armPhase) * armSwingMultiplier * dir,
                        -Math.sin(armPhase + Math.PI) * armSwingMultiplier * dir
                    ];
                    // Apply elbowBend directly for constant bend
                    currentElbowBends = [elbowBend, elbowBend];
                    useDrawArmToHand = false; // Use drawArm
                } else if (isCrouching) { // Specific arm pose for crouching
                    const crouchArmOffsetForward = 10 * (canvas.width / 600); // How much arms come forward
                    const crouchArmOffsetDown = 15 * (canvas.height / 400); // How much arms go down

                    currentLeftHandTarget = {
                        x: shoulderLeft.x - crouchArmOffsetForward * dir, // Adjust based on dir for proper perspective
                        y: shoulderLeft.y + crouchArmOffsetDown
                    };
                    currentRightHandTarget = {
                        x: shoulderRight.x + crouchArmOffsetForward * dir, // Adjust based on dir for proper perspective
                        y: shoulderRight.y + crouchArmOffsetDown
                    };
                    useDrawArmToHand = true; // Use drawArmToHand
                }
                else if (gameState === 'idle' || gameState === 'countdown') { // Ready to run arm pose for idle and countdown
                    const readyArmForwardAngle = -Math.PI / 4; // Arm forward and bent
                    const readyArmBackwardAngle = Math.PI / 4; // Arm back and bent
                    const readyElbowBend = 1.0; // Significant elbow bend

                    // For dir=1 (facing right), left arm is forward, right arm is back.
                    currentArmAngles = [readyArmForwardAngle, readyArmBackwardAngle];
                    currentElbowBends = [readyElbowBend, readyElbowBend];
                    useDrawArmToHand = false; // Use drawArm
                }
                else if (gameState === 'finished' || (!moving && gameState === 'running')) { // Normal idle arms (hands on hips) for finished state OR stopped mid-race
                    const idleArmOffsetForward = 5 * (canvas.width / 600); // Slightly forward
                    const hipToShoulderDiffY = currentHipY - shoulder.y;
                    const idleArmOffsetDown = hipToShoulderDiffY * 0.7; // Adjust this multiplier to fine-tune vertical position
                    currentLeftHandTarget = {
                        x: shoulderLeft.x - idleArmOffsetForward * dir,
                        y: shoulderLeft.y + idleArmOffsetDown
                    };
                    currentRightHandTarget = {
                        x: shoulderRight.x + idleArmOffsetForward * dir,
                        y: shoulderRight.y + idleArmOffsetDown
                    };
                    useDrawArmToHand = true; // Use drawArmToHand
                }
                else { // Default arms (straight down if no other pose applies)
                    const idleArmOffsetForward = 0;
                    const hipToShoulderDiffY = currentHipY - shoulder.y;
                    const idleArmOffsetDown = hipToShoulderDiffY * 0.7;
                    currentLeftHandTarget = {
                        x: shoulderLeft.x - idleArmOffsetForward * dir,
                        y: shoulderLeft.y + idleArmOffsetDown
                    };
                    currentRightHandTarget = {
                        x: shoulderRight.x + idleArmOffsetForward * dir,
                        y: shoulderRight.y + idleArmOffsetDown
                    };
                    useDrawArmToHand = true;
                }

                // Draw arms using the determined parameters
                if (useDrawArmToHand) {
                    drawArmToHand(shoulderLeft, currentLeftHandTarget);
                    drawArmToHand(shoulderRight, currentRightHandTarget);
                } else {
                    drawArm(shoulderLeft, upperArmLen * (canvas.height / 400), currentArmAngles[0], lowerArmLen * (canvas.height / 400), currentElbowBends[0]);
                    drawArm(shoulderRight, upperArmLen * (canvas.height / 400), currentArmAngles[1], lowerArmLen * (canvas.height / 400), currentElbowBends[1]);
                }

                ctx.restore();
            }

            function drawLeg(hip, upperLen, angle1, lowerLen, bendAmount) {
                ctx.save();
                ctx.strokeStyle = 'black';

                const jointX = hip.x + Math.sin(angle1) * upperLen;
                const jointY = hip.y + Math.cos(angle1) * upperLen;
                const lowerLegAngle = angle1 - bendAmount;
                const endX = jointX + Math.sin(lowerLegAngle) * lowerLen;
                const endY = jointY + Math.cos(lowerLegAngle) * lowerLen;

                ctx.beginPath();
                ctx.moveTo(hip.x, hip.y);
                ctx.lineTo(jointX, jointY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                ctx.beginPath();
                const scaledFootRadius = footRadius * (canvas.width / 600);
                ctx.arc(endX, endY, scaledFootRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.stroke();

                ctx.restore();
            }

            function drawArm(start, len1, angle1, len2, bendAmount) {
                const jointX = start.x + Math.sin(angle1) * len1;
                const jointY = start.y + Math.cos(angle1) * len1;
                const bendAngle = angle1 + bendAmount;
                const endX = jointX + Math.sin(bendAngle) * (len2 * 0.7);
                const endY = jointY + Math.cos(bendAngle) * (len2 * 0.7);

                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(jointX, jointY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(endX, endY, 2 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                ctx.stroke();
            }

            function drawArmToHand(shoulderPos, handPos) {
                const dx = handPos.x - shoulderPos.x;
                const dy = handPos.y - shoulderPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                let elbowX, elbowY;
                let finalHandX = handPos.x;
                let finalHandY = handPos.y;

                const scaledUpperArmLen = upperArmLen * (canvas.height / 400);
                const scaledLowerArmLen = lowerArmLen * (canvas.height / 400);

                if (dist > scaledUpperArmLen + scaledLowerArmLen) {
                    const ratio = (scaledUpperArmLen + scaledLowerArmLen) / dist;
                    elbowX = shoulderPos.x + dx * (scaledUpperArmLen / dist);
                    elbowY = shoulderPos.y + dy * (scaledUpperArmLen / dist);
                    finalHandX = shoulderPos.x + dx * ratio;
                    finalHandY = shoulderPos.y + dy * ratio;
                } else {
                    const cosAngle = (scaledUpperArmLen**2 + dist**2 - scaledLowerArmLen**2) / (2 * scaledUpperArmLen * dist);
                    const angleElbow = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
                    const targetAngle = Math.atan2(dy, dx);
                    const sign = (handPos.x < shoulderPos.x) ? 1 : -1; // Determine sign based on hand's x-position relative to shoulder
                    const shoulderAngle = targetAngle + sign * angleElbow;
                    elbowX = shoulderPos.x + Math.cos(shoulderAngle) * scaledUpperArmLen;
                    elbowY = shoulderPos.y + Math.sin(shoulderAngle) * scaledUpperArmLen;
                }

                ctx.beginPath();
                ctx.moveTo(shoulderPos.x, shoulderPos.y);
                ctx.lineTo(elbowX, elbowY);
                ctx.lineTo(finalHandX, finalHandY);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(finalHandX, finalHandY, 2 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = '#000';
                ctx.fill();
                ctx.stroke();
            }

            function drawFace(x, y, expression, faceDir) {
                const scaleFactor = canvas.width / 600;
                const eyeGap = 4 * scaleFactor, eyeY = -3 * scaleFactor, mouthY = 3 * scaleFactor;
                const eyeRadius = 2.5 * scaleFactor, pupilRadius = 1.2 * scaleFactor;
                const offsetX = faceDir === 1 ? 2 * scaleFactor : faceDir === -1 ? -2 * scaleFactor : 0;
                const mouthX = offsetX;
                const leftX = -eyeGap + offsetX;
                const rightX = eyeGap + offsetX;

                ctx.save();
                ctx.translate(x, y);

                if (isBlinking) {
                    ctx.beginPath();
                    ctx.lineWidth = 1 * scaleFactor;
                    ctx.moveTo(leftX - eyeRadius, eyeY);
                    ctx.lineTo(leftX + eyeRadius, eyeY);
                    ctx.moveTo(rightX - eyeRadius, eyeY);
                    ctx.lineTo(rightX + eyeRadius, eyeY);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.lineWidth = 0.5 * scaleFactor;
                    ctx.arc(leftX, eyeY, eyeRadius, 0, Math.PI * 2);
                    ctx.arc(rightX, eyeY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(leftX, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.arc(rightX, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.lineWidth = 1 * scaleFactor;
                if (expression === 'happy') {
                    ctx.arc(mouthX, mouthY - 2 * scaleFactor, 5 * scaleFactor, 0, Math.PI, false);
                } else if (expression === 'sad') {
                    ctx.arc(mouthX, mouthY + 2 * scaleFactor, 5 * scaleFactor, 0, Math.PI, true);
                } else if (expression === 'angry') {
                    ctx.moveTo(mouthX - 3 * scaleFactor, mouthY);
                    ctx.lineTo(mouthX + 3 * scaleFactor, mouthY);
                } else if (expression === 'surprised') {
                    ctx.arc(mouthX, mouthY, 2.5 * scaleFactor, 0, Math.PI * 2);
                } else if (expression === 'tired') {
                    ctx.moveTo(mouthX - 4 * scaleFactor, mouthY + 2 * scaleFactor);
                    ctx.lineTo(mouthX + 4 * scaleFactor, mouthY + 4 * scaleFactor);
                } else if (expression === 'trying') {
                    ctx.moveTo(mouthX - 4 * scaleFactor, mouthY);
                    ctx.lineTo(mouthX + 4 * scaleFactor, mouthY);
                } else {
                    ctx.moveTo(mouthX - 4 * scaleFactor, mouthY);
                    ctx.lineTo(mouthX + 4 * scaleFactor, mouthY);
                }
                ctx.stroke();

                ctx.restore();
            }

            // New function for drawing debug info on canvas
                        function drawDebugInfo() {
                if (!showUI) return; // Only draw if showUI is true

                ctx.save();
                ctx.fillStyle = 'black';
                ctx.font = `${14 * (canvas.width / 600)}px monospace`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                const padding = 10 * (canvas.width / 600);
                let yOffset = padding;

                ctx.fillText(`GameState: ${gameState}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`keys['a']: ${keys['a'] || false}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`keys['d']: ${keys['d'] || false}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`keys['w']: ${keys['w'] || false}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`keys['s']: ${keys['s'] || false}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`onGround: ${onGround}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`manualMode: ${manualModeCheckbox.checked}`, padding, yOffset); // Add manual mode status
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`isHurling: ${isHurling}`, padding, yOffset); // Add hurdle status
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Speed Penalty: ${speedPenaltyActive ? 'Active' : 'Inactive'}`, padding, yOffset); // Add speed penalty status
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Position: ${position.toFixed(2)}`, padding, yOffset); // Add current position
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Dir: ${dir}`, padding, yOffset); // Add current direction
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Hurdles Cleared: ${hurdlesClearedCount}`, padding, yOffset); // Add hurdles cleared count
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Last Hurdle Index Passed: ${lastHurdleIndexPassed}`, padding, yOffset); // Add last hurdle index passed
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Hurdle 3 Cleared: ${hurdle3Cleared}`, padding, yOffset); // Add hurdle 3 cleared status
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Hurdle 4 Cleared: ${hurdle4Cleared}`, padding, yOffset); // Add hurdle 4 cleared status
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Crowd Loaded: ${crowdPlayer.loaded}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Crowd Playing: ${crowdPlayer.isPlaying}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`Crowd Volume: ${crowdPlayer.volume.value.toFixed(2)}`, padding, yOffset);
                yOffset += 20 * (canvas.width / 600);
                ctx.fillText(`isCrowdSoundActive: ${isCrowdSoundActive}`, padding, yOffset); // New debug for the flag

                ctx.restore();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround();
                drawHurdles(); // Draw hurdles
                drawStickman();
                drawStopwatch();
                drawCountdownMessage();
                drawDebugInfo(); // Draw debug information
                drawHighScores(); // Draw high scores
            }

            function loop() {
                updateDimensions();
                update();
                draw();
                animationFrameId = requestAnimationFrame(loop);
            }

            // Slider event listeners
            document.getElementById('speed').addEventListener('input', function() {
                document.getElementById('speedValue').textContent = this.value;
            });
            document.getElementById('gaitAmplitude').addEventListener('input', function() {
                document.getElementById('gaitAmplitudeValue').textContent = this.value;
            });
            document.getElementById('stepFrequency').addEventListener('input', function() {
                document.getElementById('stepFrequencyValue').textContent = this.value;
            });
            document.getElementById('frontKneeBend').addEventListener('input', function() {
                document.getElementById('frontKneeBendValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMax').addEventListener('input', function() {
                document.getElementById('backKneeBendMaxValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMultiplier').addEventListener('input', function() {
                document.getElementById('backKneeBendMultiplierValue').textContent = this.value;
            });
            document.getElementById('gaitAmplitudeLeft').addEventListener('input', function() {
                document.getElementById('gaitAmplitudeLeftValue').textContent = this.value;
            });
            document.getElementById('stepFrequencyLeft').addEventListener('input', function() {
                document.getElementById('stepFrequencyLeftValue').textContent = this.value;
            });
            document.getElementById('frontKneeBendLeft').addEventListener('input', function() {
                document.getElementById('frontKneeBendLeftValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMaxLeft').addEventListener('input', function() {
                document.getElementById('backKneeBendMaxLeftValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMultiplierLeft').addEventListener('input', function() {
                document.getElementById('backKneeBendMultiplierLeftValue').textContent = this.value;
            });
            document.getElementById('elbowBend').addEventListener('input', function() {
                document.getElementById('elbowBendValue').textContent = this.value;
            });
            document.getElementById('elbowBendLeft').addEventListener('input', function() {
                document.getElementById('elbowBendLeftValue').textContent = this.value;
            });
            document.getElementById('torsoThickness').addEventListener('input', function() {
                document.getElementById('torsoThicknessValue').textContent = this.value;
            });
            document.getElementById('torsoThicknessLeft').addEventListener('input', function() {
                document.getElementById('torsoThicknessLeftValue').textContent = this.value;
            });
            document.getElementById('crouchExtraBend').addEventListener('input', function() {
                document.getElementById('crouchExtraBendValue').textContent = this.value;
            });
            document.getElementById('manualSpeedMultiplier').addEventListener('input', function() {
                document.getElementById('manualSpeedMultiplierValue').textContent = this.value;
            });
            document.getElementById('tapCurveExponent').addEventListener('input', function() {
                document.getElementById('tapCurveExponentValue').textContent = this.value;
            });
            document.getElementById('armSwingMultiplier').addEventListener('input', function() {
                document.getElementById('armSwingMultiplierValue').textContent = this.value;
            });
            document.getElementById('armSwingMultiplierLeft').addEventListener('input', function() {
                document.getElementById('armSwingMultiplierLeftValue').textContent = this.value;
            });
            // New hurdle sliders event listeners
            hurdleLeadKneeBendSelect.addEventListener('input', function() {
                document.getElementById('hurdleLeadKneeBendValue').textContent = this.value;
            });
            hurdleTrailKneeBendSelect.addEventListener('input', function() {
                document.getElementById('hurdleTrailKneeBendValue').textContent = this.value;
            });

            // Toggle Controls Button Event Listener
            toggleControlsBtn.addEventListener('click', () => {
                showUI = !showUI; // Toggle the visibility flag
                if (showUI) {
                    controlsDiv.style.display = 'grid'; // Show the control panel
                    toggleControlsBtn.textContent = 'Hide UI';
                } else {
                    controlsDiv.style.display = 'none'; // Hide the control panel
                    toggleControlsBtn.textContent = 'Show UI';
                }
                draw(); // Redraw the canvas to update debug info visibility
            });

            // Action Button Event Listener (for Start/Reset)
            actionButton.addEventListener('click', async () => { // Made async to await Tone.context.resume()
                // IMPORTANT: Resume AudioContext on user gesture for reliable audio playback
                if (Tone.context.state !== 'running') {
                    try {
                        await Tone.context.resume();
                        console.log("AudioContext resumed by action button click.");
                    } catch (e) {
                        console.error("Failed to resume AudioContext on action button click:", e);
                    }
                }

                if (gameState === 'idle') {
                    startCountdown();
                } else if (gameState === 'running' || gameState === 'finished') {
                    resetGame();
                }
            });

            // Populate hurdles array
            for (let i = 0; i < numberOfHurdles; i++) {
                const meterPosition = initialHurdleMeter + (i * hurdleInterval);
                const lane = 2; // All hurdles in lane 2
                hurdles.push({ meterPosition: meterPosition, lane: lane, isFallen: false });
            }

            // Load high scores on initial load
            loadHighScores();

            // Initialize y position after all constants are defined
            resetGame(); // Call resetGame to ensure y is correctly initialized at start

            loop();
        }); // End of DOMContentLoaded listener
</script>
</body>
</html>

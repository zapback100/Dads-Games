<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Space Invaders</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            background: #000;
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive; /* Retro font */
            color: #fff;
        }
        canvas {
            /* Removed border: 2px solid #fff; */
            background: #000;
            image-rendering: pixelated;
            max-width: 95vw; /* Ensure canvas fits wider screens */
            max-height: 80vh; /* Ensure canvas fits taller screens */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        .control-button {
            background-color: #00ff00;
            color: #000;
            border: 2px solid #00aa00;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.1s, transform 0.1s;
            box-shadow: 0 5px #00aa00;
            user-select: none; /* Prevent text selection on touch */
            font-family: 'Press Start 2P', cursive;
        }
        .control-button:active {
            background-color: #00cc00;
            transform: translateY(2px);
            box-shadow: 0 3px #00aa00;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            color: #00ff00;
            display: none; /* Hidden by default */
            z-index: 1000;
        }
        .message-box button {
            background-color: #00ff00;
            color: #000;
            border: 2px solid #00aa00;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Press Start 2P', cursive;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="controls" id="mobileControls">
        <button class="control-button" id="leftButton">←</button>
        <button class="control-button" id="shootButton">FIRE</button>
        <button class="control-button" id="rightButton">→</button>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageButton">OK</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const mobileControls = document.getElementById('mobileControls');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const shootButton = document.getElementById('shootButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageButton = document.getElementById('messageButton');

        // Game scaling factor (based on original 800x600)
        let scaleX = 1;
        let scaleY = 1;

        // Player
        const player = {
            x: 0, // Will be set dynamically
            y: 0, // Will be set dynamically
            width: 26, // Adjusted for classic size (original is 13 pixels wide)
            height: 16, // Adjusted for classic size (original is 8 pixels high)
            speed: 5,
            dx: 0,
            lives: 3,
            isHit: false,
            hitTimer: 0,
            hitDuration: 120 // Frames of invincibility/flash
        };

        // Player Bullets
        const bullets = [];
        const bulletSpeed = 7;
        const bulletWidth = 2; // Adjusted for classic size
        const bulletHeight = 8; // Adjusted for classic size
        let canShoot = true; // Controls player shooting cooldown
        let bulletOnScreen = false; // Controls one bullet at a time
        const shootCooldown = 120; // milliseconds - FASTER GUN

        // Alien Bombs
        const bombs = [];
        const bombSpeed = 2; // Adjusted for slower bombs
        const bombWidth = 2; // Adjusted for classic size
        const bombHeight = 8; // Adjusted for classic size
        const bombDropChance = 0.001; // Decreased chance for fewer bombs

        // Aliens
        const aliens = [];
        const alienRows = 5;
        const alienCols = 11;
        // Define base alien dimensions for consistent layout and movement calculations
        const ALIEN_BASE_WIDTH = 22; 
        const ALIEN_BASE_HEIGHT = 16; 

        let baseAlienSpeed = 0.2; // Base speed for aliens - made even SLOWER for initial feel
        let alienSpeed = baseAlienSpeed; // Current speed, will increase
        let alienDirection = 1;
        let alienMoveDown = false;
        let aliensAliveCount = 0;
        let totalAliens = alienRows * alienCols;
        const alienHorizontalSpacing = 4; // Pixels between aliens horizontally (adjusted for denser formation)
        const alienVerticalSpacing = 4; // Pixels between aliens vertically (adjusted for denser formation)

        // Alien Animation
        let alienAnimationFrame = 0; // 0 or 1
        let alienAnimationTimer = 15; // Frames before switching animation frame (slower animation)

        // Alien Sprites (pixel maps) - Frame 1
        const alien10PtsMap_frame1 = [ // Smallest alien (top row) - 11x8 original pixels
            [0,0,0,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,1,0,1,1,1,1,1,0,1,1], 
            [1,0,1,1,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,1,0,1],
            [0,1,0,1,1,0,1,1,0,1,0] // Legs spread
        ];
        // Alien Sprites (pixel maps) - Frame 2 (legs together)
        const alien10PtsMap_frame2 = [
            [0,0,0,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,1,0,1,1,1,1,1,0,1,1], 
            [1,0,1,1,1,1,1,1,1,0,1],
            [0,1,0,1,1,0,1,1,0,1,0], // Legs together
            [1,0,1,0,0,0,0,0,1,0,1]
        ];

        // Crab alien (middle two rows) - 11x8 original pixels - Frame 1
        const alien20PtsMap_frame1 = [ 
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,0,0,1,0,0,0,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,1,0,1,0,1,0,1,0], // Legs spread
            [1,0,1,0,1,0,1,0,1,0,1]
        ];
        // Crab alien (middle two rows) - 11x8 original pixels - Frame 2
        const alien20PtsMap_frame2 = [ 
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,0,0,1,0,0,0,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,0,1,0,1,0,1,0,1,0,1], // Legs together
            [0,1,0,1,0,1,0,1,0,1,0]
        ];

        // Octopus alien (bottom two rows) - 12x8 original pixels - Frame 1
        const alien40PtsMap_frame1 = [ 
            [0,0,0,0,1,1,1,1,0,0,0,0], 
            [0,0,0,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [0,1,0,1,0,1,0,1,0,1,0,1], // Legs spread
            [1,0,1,0,1,0,1,0,1,0,1,0]
        ];
        // Octopus alien (bottom two rows) - 12x8 original pixels - Frame 2
        const alien40PtsMap_frame2 = [ 
            [0,0,0,0,1,1,1,1,0,0,0,0], 
            [0,0,0,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [1,0,1,0,1,0,1,0,1,0,1,0], // Legs together
            [0,1,0,1,0,1,0,1,0,1,0,1]
        ];


        // Alien Explosion Sprite (from image_8709bd.png) - 12x6 original pixels
        const alienExplosionMap = [
            [0,0,1,1,0,0,0,0,1,1,0,0],
            [0,1,0,0,1,0,0,1,0,0,1,0],
            [1,0,0,0,0,1,1,0,0,0,0,1],
            [1,0,0,0,0,1,1,0,0,0,0,1],
            [0,1,0,0,1,0,0,1,0,0,1,0],
            [0,0,1,1,0,0,0,0,1,1,0,0]
        ];
        const explosionDuration = 10; // Frames to show explosion

        // Barriers
        const barriers = [];
        const barrierWidth = 40; // Adjusted for classic size (original is 10 pixels wide for map)
        const barrierHeight = 32; // Adjusted for classic size (original is 8 pixels high for map)
        const barrierPixelGridWidth = 10; 
        const barrierPixelGridHeight = 8; 
        const barrierDestructionRadius = 1; // Radius of pixels to destroy around hit point (e.g., 1 means 3x3 block)

        // UFO
        const ufo = {
            x: 0,
            y: 30, // Position at the top
            width: 32, // Adjusted for classic size (original is 16 pixels wide)
            height: 14, // Adjusted for classic size (original is 7 pixels high)
            speed: 2.5, // SLOWER UFO
            alive: false,
            direction: 1, // 1 for right, -1 for left
            points: 250 // Updated to 250 points for shooting UFO
        };
        let ufoSpawnTimer = 0;
        const ufoSpawnInterval = 1000; // Minimum frames between UFO spawns (approx 16 seconds)

        // Game state
        let score = 0;
        let highScore = 0; // New: High Score variable
        let gameOver = false;
        let gameStarted = false;
        let gamePaused = false; // New: Game paused state
        let animationFrameId;
        let playerDeathTimer = 0; // Timer for player death pause

        // Starfield
        const stars = [];
        const numStars = 100;

        // Tone.js Synths for sound effects
        let shootSynth, explodeSynth, bombSynth;

        // --- Sound Configurations ---
        const ufoSoundUrl = 'https://raw.githubusercontent.com/zapback100/Dads-Games/Space/ufo_lowpitch.wav';
        const shootSoundUrl = 'https://raw.githubusercontent.com/zapback100/Dads-Games/shoot.wav'; // New shoot sound URL

        let ufoPlayer = null; 
        let ufoSynth = null; 
        let shootPlayer = null; // New Tone.Player for external shoot sound
        let synthesizedShootSynth = null; // For fallback synthesized shoot sound

        function setupAudio() {
            // Initialize Tone.js context
            Tone.start();

            // Player shoot sound
            // Prioritize external URL, fallback to synthesized
            if (shootSoundUrl) {
                shootPlayer = new Tone.Player({
                    url: shootSoundUrl,
                    autostart: false,
                    volume: -10 // Adjust volume as needed
                }).toDestination();

                shootPlayer.onerror = (e) => {
                    console.error("Error loading shoot sound:", e);
                    shootPlayer = null; // Clear the player
                    synthesizedShootSynth = new Tone.Synth({
                        oscillator: { type: "square" },
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
                    }).toDestination();
                    console.warn("Falling back to synthesized shoot sound.");
                };
            } else {
                synthesizedShootSynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
                }).toDestination();
            }

            // Alien explosion sound
            explodeSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001,
                    decay: 0.2,
                    sustain: 0.01,
                    release: 0.2
                }
            }).toDestination();

            // Alien bomb drop sound
            bombSynth = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 8,
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 0.4
                }
            }).toDestination();

            // Initialize UFO sound based on whether a URL is provided
            if (ufoSoundUrl) {
                ufoPlayer = new Tone.Player({
                    url: ufoSoundUrl,
                    loop: true, 
                    autostart: false,
                    volume: -10 
                }).toDestination();

                ufoPlayer.onerror = (e) => {
                    console.error("Error loading UFO sound:", e);
                    ufoPlayer = null; 
                    ufoSynth = new Tone.PulseOscillator('A3', 0.2).toDestination();
                    ufoSynth.volume.value = -10;
                    console.warn("Falling back to synthesized UFO sound.");
                };
            } else {
                ufoSynth = new Tone.PulseOscillator('A3', 0.2).toDestination(); 
                ufoSynth.volume.value = -10; 
            }
        }

        // Show custom message box
        function showMessageBox(message, buttonText = "OK", callback = null) {
            messageText.textContent = message;
            messageButton.textContent = buttonText;
            messageBox.style.display = 'block';
            messageButton.onclick = () => {
                messageBox.style.display = 'none';
                if (callback) callback();
            };
        }

        // Initialize stars for background
        function initStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5 + 0.5,
                    alpha: Math.random()
                });
            }
        }

        // Draw stars
        function drawStars() {
            ctx.fillStyle = '#fff';
            stars.forEach(star => {
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
                star.y += 0.1; // Slowly move stars down
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            ctx.globalAlpha = 1.0;
        }

        // Initialize aliens
        function initAliens() {
            aliens.length = 0;
            aliensAliveCount = 0;
            totalAliens = alienRows * alienCols; // Reset total aliens
            // Calculate starting X to center the alien formation
            const formationWidth = alienCols * (ALIEN_BASE_WIDTH * scaleX + alienHorizontalSpacing * scaleX) - alienHorizontalSpacing * scaleX; 
            const startX = (canvas.width - formationWidth) / 2;
            const startY = 80 * scaleY; // Adjusted start Y for aliens

            for (let row = 0; row < alienRows; row++) {
                for (let col = 0; col < alienCols; col++) {
                    let alienPixelMap1, alienPixelMap2;
                    let alienBaseWidth, alienBaseHeight;

                    // Assign different alien types based on row
                    if (row === 0) { // Top row
                        alienPixelMap1 = alien40PtsMap_frame1; // Largest alien
                        alienPixelMap2 = alien40PtsMap_frame2;
                        alienBaseWidth = 24; // Original width of this alien (12 pixels * 2 scale)
                        alienBaseHeight = 16; // Original height of this alien (8 pixels * 2 scale)
                    } else if (row === 1 || row === 2) { // Middle two rows
                        alienPixelMap1 = alien20PtsMap_frame1; // Crab alien
                        alienPixelMap2 = alien20PtsMap_frame2;
                        alienBaseWidth = 22; // Original width of this alien (11 pixels * 2 scale)
                        alienBaseHeight = 16; // Original height of this alien (8 pixels * 2 scale)
                    } else { // Bottom two rows
                        alienPixelMap1 = alien10PtsMap_frame1; // Smallest alien
                        alienPixelMap2 = alien10PtsMap_frame2;
                        alienBaseWidth = 22; // Original width of this alien (11 pixels * 2 scale)
                        alienBaseHeight = 16; // Original height of this alien (8 pixels * 2 scale)
                    }

                    aliens.push({
                        x: startX + col * (ALIEN_BASE_WIDTH * scaleX + alienHorizontalSpacing * scaleX), // Use consistent base width for horizontal spacing
                        y: startY + row * (ALIEN_BASE_HEIGHT * scaleY + alienVerticalSpacing * scaleY), // Use consistent base height for vertical spacing
                        width: alienBaseWidth * scaleX,
                        height: alienBaseHeight * scaleY,
                        pixelMap_frame1: alienPixelMap1, // Store the specific pixel map for this alien
                        pixelMap_frame2: alienPixelMap2,
                        alive: true,
                        health: 2, // Aliens require 2 hits
                        isExploding: false, // Flag for explosion animation
                        explosionTimer: 0 // Timer for explosion animation
                    });
                    aliensAliveCount++;
                }
            }
        }

        // Initialize barriers
        function initBarriers() {
            barriers.length = 0;
            // Position barriers slightly higher to make space for bottom UI
            const barrierY = canvas.height - 100 * scaleY; // Adjusted barrier Y
            const numBarriers = 4;
            const totalBarriersWidth = numBarriers * barrierWidth * scaleX; 
            const totalSpacing = canvas.width - totalBarriersWidth;
            const barrierSpacing = totalSpacing / (numBarriers + 1); // Evenly distribute

            // Define the base pixel map for a barrier
            const baseBarrierPixelMap = [
                [0,0,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1],
                [1,1,1,0,0,0,0,1,1,1], 
                [1,0,0,0,0,0,0,0,0,1], 
            ];

            for (let i = 0; i < numBarriers; i++) {
                barriers.push({
                    x: barrierSpacing + i * (barrierWidth * scaleX + barrierSpacing),
                    y: barrierY,
                    width: barrierWidth * scaleX,
                    height: barrierHeight * scaleY,
                    pixelMap: JSON.parse(JSON.stringify(baseBarrierPixelMap))
                });
            }
        }

        // Reset game state
        function resetGame() {
            // Player Y adjusted to be above the green line
            player.y = (canvas.height - 40 * scaleY) - player.height * scaleY - (2 * scaleY); 
            player.x = canvas.width / 2 - player.width / 2;
            player.lives = 3;
            score = 0;
            gameOver = false;
            gameStarted = true;
            gamePaused = false; // Ensure game is not paused on reset
            bullets.length = 0;
            bombs.length = 0;
            alienDirection = 1;
            baseAlienSpeed = 0.2; // Reset alien base speed for new game
            alienSpeed = baseAlienSpeed; // Reset alien current speed
            player.isHit = false;
            player.hitTimer = 0;
            bulletOnScreen = false; // Reset bullet state
            ufo.alive = false; // Ensure UFO is not active
            ufoSpawnTimer = ufoSpawnInterval; // Reset UFO timer
            playerDeathTimer = 0; // Reset player death timer
            initAliens();
            initBarriers();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            update(); // Start the game loop
        }

        // Adjust canvas size and scale factors
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.95; // Use 95% of window width
            canvas.height = window.innerHeight * 0.8; // Use 80% of window height for game area

            // Ensure a minimum size to prevent elements from becoming too small
            if (canvas.width < 600) canvas.width = 600;
            if (canvas.height < 400) canvas.height = 400;

            scaleX = canvas.width / 800;
            scaleY = canvas.height / 600;

            // Re-position player and re-initialize game elements based on new scale
            player.width = 26 * scaleX; 
            player.height = 16 * scaleY; 
            // Player Y adjusted to be above the green line
            player.y = (canvas.height - 40 * scaleY) - player.height - (2 * scaleY); 
            player.x = canvas.width / 2 - player.width / 2;

            initAliens();
            initBarriers();
            initStars();

            // Adjust mobile controls visibility based on screen width
            if (window.innerWidth < 768) { // Example breakpoint for mobile
                mobileControls.style.display = 'flex';
            } else {
                mobileControls.style.display = 'none';
            }
        }

        // Define pixel maps for start screen aliens and UFO
        const ufoStartScreenMap = [ // UFO pixel map for start screen
            [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // Bottom "legs"
        ];

        // Helper function to draw pixel art on start screen
        function drawPixelArt(pixelMap, x, y, baseWidth, baseHeight, color) {
            ctx.fillStyle = color;
            const pixelSizeX = (baseWidth * scaleX) / pixelMap[0].length;
            const pixelSizeY = (baseHeight * scaleY) / pixelMap.length;

            for (let row = 0; row < pixelMap.length; row++) {
                for (let col = 0; col < pixelMap[row].length; col++) {
                    if (pixelMap[row][col] === 1) {
                        ctx.fillRect(x + col * pixelSizeX, y + row * pixelSizeY, pixelSizeX, pixelSizeY);
                    }
                }
            }
        }

        // Draw start screen
        function drawStartScreen() {
            ctx.textAlign = 'center';

            // "SPACE"
            ctx.fillStyle = '#fff';
            ctx.font = `${60 * scaleY}px 'Press Start 2P'`;
            ctx.fillText('SPACE', canvas.width / 2, canvas.height / 2 - 180 * scaleY);

            // "INVADERS"
            ctx.fillStyle = '#0f0';
            ctx.font = `${60 * scaleY}px 'Press Start 2P'`;
            ctx.fillText('INVADERS', canvas.width / 2, canvas.height / 2 - 120 * scaleY);

            // Alien points section
            const startYOffset = canvas.height / 2 - 20 * scaleY;
            const lineHeight = 40 * scaleY;
            const alienIconSize = 22; // Base size for aliens on start screen

            // 10 PTS Alien
            drawPixelArt(alien10PtsMap_frame1, canvas.width / 2 - 100 * scaleX, startYOffset, alienIconSize, alienIconSize * (alien10PtsMap_frame1.length / alien10PtsMap_frame1[0].length), '#fff');
            ctx.fillStyle = '#fff';
            ctx.font = `${20 * scaleY}px 'Press Start 2P'`;
            ctx.textAlign = 'left';
            ctx.fillText('= 10 PTS', canvas.width / 2 - 50 * scaleX, startYOffset + (alienIconSize * scaleY / 2) + 8 * scaleY);

            // 20 PTS Alien
            drawPixelArt(alien20PtsMap_frame1, canvas.width / 2 - 100 * scaleX, startYOffset + lineHeight, alienIconSize, alienIconSize * (alien20PtsMap_frame1.length / alien20PtsMap_frame1[0].length), '#fff');
            ctx.fillText('= 20 PTS', canvas.width / 2 - 50 * scaleX, startYOffset + lineHeight + (alienIconSize * scaleY / 2) + 8 * scaleY);

            // 40 PTS Alien
            // Note: alien40PtsMap is 12 pixels wide, so adjust baseWidth accordingly for drawing
            drawPixelArt(alien40PtsMap_frame1, canvas.width / 2 - 100 * scaleX, startYOffset + 2 * lineHeight, 24, 16, '#fff'); 
            ctx.fillText('= 40 PTS', canvas.width / 2 - 50 * scaleX, startYOffset + 2 * lineHeight + (alienIconSize * scaleY / 2) + 8 * scaleY);

            // UFO ??? PTS
            const ufoIconSize = 32; // Base size for UFO on start screen
            drawPixelArt(ufoStartScreenMap, canvas.width / 2 - 100 * scaleX, startYOffset + 3 * lineHeight, ufoIconSize, ufoIconSize * (ufoStartScreenMap.length / ufoStartScreenMap[0].length), '#f00');
            ctx.fillText('= ??? PTS', canvas.width / 2 - 50 * scaleX, startYOffset + 3 * lineHeight + (ufoIconSize * scaleY / 2) + 8 * scaleY);


            // "PLAY SPACE INVADERS"
            ctx.fillStyle = '#00ff00';
            ctx.font = `${28 * scaleY}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText('PLAY SPACE INVADERS', canvas.width / 2, canvas.height - 80 * scaleY);
            ctx.textAlign = 'left'; // Reset to default
        }

        // Draw player (retro spaceship - blocky design)
        function drawPlayer() {
            if (player.isHit && Math.floor(player.hitTimer / 10) % 2 === 0) {
                // Flash effect when hit
                return;
            }
            ctx.fillStyle = '#0f0'; // Green player ship
            const px = player.x;
            const py = player.y;
            const pw = player.width;
            const ph = player.height;

            // Original player sprite is 13x8 pixels.
            const pixelSizeX = pw / 13;
            const pixelSizeY = ph / 8;

            // Draw the player pixel by pixel to match the blocky retro style
            // Using a pixel map for clarity
            const playerPixelMap = [
                [0,0,0,0,0,1,0,0,0,0,0,0,0], // Cannon
                [0,0,0,0,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1], // Main body
                [1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1],
            ];

            for (let row = 0; row < playerPixelMap.length; row++) {
                for (let col = 0; col < playerPixelMap[row].length; col++) {
                    if (playerPixelMap[row][col] === 1) {
                        ctx.fillRect(px + col * pixelSizeX, py + row * pixelSizeY, pixelSizeX, pixelSizeY);
                    }
                }
            }
        }

        // Draw player bullets
        function drawBullets() {
            ctx.fillStyle = '#fff';
            bullets.forEach(bullet => {
                ctx.fillRect(bullet.x, bullet.y, bullet.width * scaleX, bullet.height * scaleY);
            });
        }

        // Draw alien bombs
        function drawBombs() {
            ctx.fillStyle = '#f00'; // Red bombs
            bombs.forEach(bomb => {
                ctx.fillRect(bomb.x, bomb.y, bomb.width * scaleX, bomb.height * scaleY);
            });
        }

        // Draw aliens (classic pixel art from image)
        function drawAliens() {
            aliens.forEach(alien => {
                if (alien.alive) {
                    ctx.globalAlpha = alien.health === 2 ? 1.0 : 0.6; // Faded if 1 hit left
                    ctx.fillStyle = '#fff'; // WHITE for classic look
                    const ax = alien.x;
                    const ay = alien.y;
                    const aw = alien.width;
                    const ah = alien.height;

                    let currentPixelMap;
                    if (alien.isExploding) {
                        currentPixelMap = alienExplosionMap;
                        // Explosion map is 12x6 pixels. Need to scale correctly.
                        const explosionPixelSizeX = aw / alienExplosionMap[0].length;
                        const explosionPixelSizeY = ah / alienExplosionMap.length;
                        ctx.fillStyle = '#fff'; // Explosion is white
                        for (let row = 0; row < currentPixelMap.length; row++) {
                            for (let col = 0; col < currentPixelMap[row].length; col++) {
                                if (currentPixelMap[row][col] === 1) {
                                    ctx.fillRect(ax + col * explosionPixelSizeX, ay + row * explosionPixelSizeY, explosionPixelSizeX, explosionPixelSizeY);
                                }
                            }
                        }
                    } else {
                        // Use the appropriate pixel map based on the current animation frame
                        currentPixelMap = alienAnimationFrame === 0 ? alien.pixelMap_frame1 : alien.pixelMap_frame2;
                        const pixelSizeX = aw / currentPixelMap[0].length;
                        const pixelSizeY = ah / currentPixelMap.length;

                        for (let row = 0; row < currentPixelMap.length; row++) {
                            for (let col = 0; col < currentPixelMap[row].length; col++) {
                                if (currentPixelMap[row][col] === 1) {
                                    ctx.fillRect(ax + col * pixelSizeX, ay + row * pixelSizeY, pixelSizeX, pixelSizeY);
                                }
                            }
                        }
                    }
                    ctx.globalAlpha = 1.0;
                }
            });
        }

        // Draw barriers (with visual damage)
        function drawBarriers() {
            barriers.forEach(barrier => {
                // Only draw if the barrier still has active pixels
                const hasActivePixels = barrier.pixelMap.some(row => row.some(pixel => pixel === 1));
                if (hasActivePixels) {
                    const bx = barrier.x;
                    const by = barrier.y;
                    const bw = barrier.width;
                    const bh = barrier.height;

                    const pixelSizeX = bw / barrierPixelGridWidth;
                    const pixelSizeY = bh / barrierPixelGridHeight;

                    ctx.fillStyle = '#0f0'; // GREEN for classic look
                    for (let row = 0; row < barrierPixelGridHeight; row++) {
                        for (let col = 0; col < barrierPixelGridWidth; col++) {
                            if (barrier.pixelMap[row][col] === 1) {
                                ctx.fillRect(bx + col * pixelSizeX, by + row * pixelSizeY, pixelSizeX, pixelSizeY);
                            }
                        }
                    }
                }
            });
        }

        // Draw UFO (red, pixelated)
        function drawUFO() {
            if (ufo.alive) {
                ctx.fillStyle = '#f00'; // Red UFO - kept as red as per image
                const ux = ufo.x;
                const uy = ufo.y;
                const uw = ufo.width;
                const uh = ufo.height;

                // UFO pixel map based on image_86b343.png (16x7 pixels)
                const ufoPixelMap = [
                    [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
                    [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
                    [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
                    [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
                    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // Bottom "legs"
                ];

                const pixelSizeX = uw / ufoPixelMap[0].length; 
                const pixelSizeY = uh / ufoPixelMap.length;  

                for (let row = 0; row < ufoPixelMap.length; row++) {
                    for (let col = 0; col < ufoPixelMap[row].length; col++) {
                        if (ufoPixelMap[row][col] === 1) {
                            ctx.fillRect(ux + col * pixelSizeX, uy + row * pixelSizeY, pixelSizeX, pixelSizeY);
                        }
                    }
                }
            }
        }

        // Draw score and lives (SCORE<1> 0000 format)
        function drawScore() {
            ctx.fillStyle = '#fff';
            ctx.font = `${20 * scaleY}px 'Press Start 2P'`; // Font size based on scale
            ctx.textAlign = 'left';

            // SCORE<1>
            ctx.fillText(`SCORE<1>`, 20 * scaleX, 30 * scaleY); // Adjusted X position
            ctx.fillText(`${String(score).padStart(4, '0')}`, 20 * scaleX, 55 * scaleY); // Adjusted X position

            // HI-SCORE
            ctx.textAlign = 'center';
            ctx.fillText(`HI-SCORE`, canvas.width / 2, 30 * scaleY);
            ctx.fillText(`${String(highScore).padStart(4, '0')}`, canvas.width / 2, 55 * scaleY);

            // SCORE<2> (Placeholder for 2-player score)
            ctx.textAlign = 'right';
            ctx.fillText(`SCORE<2>`, canvas.width - 20 * scaleX, 30 * scaleY); // Adjusted X position
            ctx.fillText(`0000`, canvas.width - 20 * scaleX, 55 * scaleY); // Adjusted X position

            // Bottom line for lives and credit
            ctx.fillStyle = '#0f0'; // Green line
            ctx.fillRect(0, canvas.height - 40 * scaleY, canvas.width, 2 * scaleY); // Adjusted Y position of the line

            // Lives at bottom left (numerical display positioned below green line)
            ctx.textAlign = 'left';
            ctx.fillText(`${player.lives}`, 20 * scaleX, canvas.height - 15 * scaleY); // Adjusted Y to be below the line

            // Draw lives as player ship icons at bottom left
            const lifeIconWidth = player.width * 0.8; // Adjusted life icon size
            const lifeIconHeight = player.height * 0.8; // Adjusted life icon size
            const lifeStartX = 40 * scaleX; // Start position for icons (adjusted)
            const lifeY = canvas.height - 35 * scaleY; // Y position for life icons (aligned with green line)

            const lifePlayerPixelMap = [
                [0,0,0,0,0,1,0,0,0,0,0,0,0],
                [0,0,0,0,1,1,1,1,1,0,0,0,0],
                [0,0,0,1,1,1,1,1,1,1,0,0,0],
                [0,0,1,1,1,1,1,1,1,1,1,0,0],
                [0,1,1,1,1,1,1,1,1,1,1,1,0],
                [1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1],
            ];

            for (let i = 0; i < player.lives; i++) {
                const lx = lifeStartX + (lifeIconWidth + 5 * scaleX) * i; // Spacing between icons
                const ly = lifeY;

                ctx.fillStyle = '#0f0'; // Green for life icons
                const iconPixelSizeX = lifeIconWidth / 13;
                const iconPixelSizeY = lifeIconHeight / 8;

                for (let row = 0; row < lifePlayerPixelMap.length; row++) {
                    for (let col = 0; col < lifePlayerPixelMap[row].length; col++) {
                        if (lifePlayerPixelMap[row][col] === 1) {
                            ctx.fillRect(lx + col * iconPixelSizeX, ly + row * iconPixelSizeY, iconPixelSizeX, iconPixelSizeY);
                        }
                    }
                }
            }

            // CREDIT 00 at bottom right
            ctx.textAlign = 'right';
            ctx.fillText(`CREDIT 00`, canvas.width - 20 * scaleX, canvas.height - 15 * scaleY); // Adjusted Y to align with lives number

            // Pause message
            if (gamePaused) {
                ctx.fillStyle = '#00ff00';
                ctx.font = `${30 * scaleY}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        // Move player
        function movePlayer() {
            player.x += player.dx * scaleX;
            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;
        }

        // Move player bullets
        function moveBullets() {
            bullets.forEach((bullet, index) => {
                bullet.y -= bulletSpeed * scaleY;
                if (bullet.y < 0) {
                    bullets.splice(index, 1);
                    bulletOnScreen = false; // Bullet left screen
                }
            });
        }

        // Move alien bombs
        function moveBombs() {
            bombs.forEach((bomb, index) => {
                bomb.y += bombSpeed * scaleY;
                if (bomb.y > canvas.height) {
                    bombs.splice(index, 1);
                }
            });
        }

        // Drop bombs from aliens
        function dropBombs() {
            // Only aliens in the bottom-most row of their column can shoot
            const bottomAliens = new Map(); // Map column index to bottom-most alien

            aliens.forEach(alien => {
                if (alien.alive && !alien.isExploding) { // Only alive, non-exploding aliens can shoot
                    const col = Math.floor((alien.x - (canvas.width - (alienCols * (ALIEN_BASE_WIDTH * scaleX + alienHorizontalSpacing * scaleX))) / 2) / (ALIEN_BASE_WIDTH * scaleX + alienHorizontalSpacing * scaleX)); // Use a consistent width for column calculation
                    if (!bottomAliens.has(col) || alien.y > bottomAliens.get(col).y) {
                        bottomAliens.set(col, alien);
                    }
                }
            });

            bottomAliens.forEach(alien => {
                if (Math.random() < bombDropChance) {
                    bombs.push({
                        x: alien.x + alien.width / 2 - bombWidth * scaleX / 2,
                        y: alien.y + alien.height,
                        width: bombWidth,
                        height: bombHeight
                    });
                    try {
                        bombSynth.triggerAttackRelease('C3', '8n'); // Play a bomb sound
                    } catch (e) {
                        console.log('Bomb sound playback failed:', e);
                    }
                }
            });
        }

        // Move aliens
        function moveAliens() {
            let maxX = 0;
            let minX = canvas.width;
            let shouldMoveDown = false;
            let currentLowestAlienY = 0; // Track the lowest alien's Y position

            // Calculate current alien speed based on remaining aliens
            // The more aliens killed, the faster the remaining ones move
            // Linear interpolation from baseSpeed to baseSpeed * 3 as aliensAliveCount goes from totalAliens to 1
            const speedFactor = 1 + (2 * (1 - (aliensAliveCount / totalAliens)));
            alienSpeed = baseAlienSpeed * speedFactor;

            aliens.forEach(alien => {
                if (alien.alive && !alien.isExploding) { // Only move non-exploding aliens
                    alien.x += alienSpeed * alienDirection * scaleX;
                    // Update minX, maxX based on individual alien positions
                    if (alien.x + alien.width > maxX) maxX = alien.x + alien.width;
                    if (alien.x < minX) minX = alien.x;
                    if (alien.y + alien.height > currentLowestAlienY) currentLowestAlienY = alien.y + alien.height;
                }
            });

            // Check if any alien hits the canvas edge
            if (maxX > canvas.width || minX < 0) {
                alienDirection *= -1; // Reverse horizontal direction
                shouldMoveDown = true; // Flag to move down
            }

            if (shouldMoveDown) {
                aliens.forEach(alien => {
                    if (alien.alive && !alien.isExploding) { // Only move down non-exploding aliens
                        alien.y += ALIEN_BASE_HEIGHT * scaleY; // Use ALIEN_BASE_HEIGHT for consistent vertical step
                    }
                });
            }

            // Check if aliens reached player's level
            if (aliensAliveCount > 0 && currentLowestAlienY > player.y) {
                player.lives--;
                player.isHit = true;
                player.hitTimer = player.hitDuration;
                if (player.lives <= 0) {
                    // Player died, start death timer
                    explodeSynth.triggerAttackRelease('8n'); // Play explosion sound
                    playerDeathTimer = 90; // Approx 1.5 seconds pause (90 frames at 60fps)
                } else {
                    // Reset aliens to top, clear bullets/bombs, but keep score
                    initAliens(); // Re-initialize aliens for next wave
                    bullets.length = 0;
                    bombs.length = 0;
                    bulletOnScreen = false; // Reset bullet state
                }
            }
        }

        // Move UFO
        function moveUFO() {
            if (ufo.alive) {
                ufo.x += ufo.speed * ufo.direction * scaleX;
                // If UFO goes off screen, make it inactive
                if (ufo.direction === 1 && ufo.x > canvas.width) {
                    ufo.alive = false;
                    try {
                        // Use ufoPlayer if available, otherwise ufoSynth
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } catch (e) {
                        console.log('UFO sound stop failed:', e);
                    }
                } else if (ufo.direction === -1 && ufo.x + ufo.width < 0) {
                    ufo.alive = false;
                    try {
                        // Use ufoPlayer if available, otherwise ufoSynth
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } catch (e) {
                        console.log('UFO sound stop failed:', e);
                    }
                }
            } else {
                // Spawn UFO periodically
                ufoSpawnTimer--;
                if (ufoSpawnTimer <= 0) {
                    ufo.alive = true;
                    ufo.direction = Math.random() < 0.5 ? 1 : -1; // Random direction
                    ufo.x = ufo.direction === 1 ? -ufo.width : canvas.width; // Start off-screen
                    ufoSpawnTimer = ufoSpawnInterval + Math.random() * ufoSpawnInterval; // Next spawn interval
                    try {
                        // Use ufoPlayer if available, otherwise ufoSynth
                        if (ufoPlayer) { ufoPlayer.start(); }
                        else if (ufoSynth) { ufoSynth.start(); }
                    } catch (e) {
                        console.log('UFO sound start failed:', e);
                    }
                }
            }
        }


        // Check collisions
        function checkCollisions() {
            // Player bullets vs Aliens
            bullets.forEach((bullet, bulletIndex) => {
                aliens.forEach((alien, alienIndex) => {
                    if (alien.alive && !alien.isExploding && // Only hit non-exploding aliens
                        bullet.x < alien.x + alien.width &&
                        bullet.x + bullet.width * scaleX > alien.x &&
                        bullet.y < alien.y + alien.height &&
                        bullet.y + bullet.height * scaleY > alien.y) {
                        
                        alien.health--;
                        bullets.splice(bulletIndex, 1); // Remove bullet
                        bulletOnScreen = false; // Bullet removed, can shoot again
                        
                        if (alien.health <= 0) {
                            alien.isExploding = true; // Start explosion animation
                            alien.explosionTimer = explosionDuration;
                            aliensAliveCount--; // Decrement count when alien is effectively destroyed
                            score += 10; // All aliens give 10 points in this version
                            try {
                                explodeSynth.triggerAttackRelease('8n'); // Play explosion sound
                            } catch (e) {
                                console.log('Explosion sound playback failed:', e);
                            }
                        }
                    }
                });

                // Player bullets vs Barriers
                barriers.forEach((barrier, barrierIndex) => {
                    if (bullet.x < barrier.x + barrier.width &&
                        bullet.x + bullet.width * scaleX > barrier.x &&
                        bullet.y < barrier.y + barrier.height &&
                        bullet.y + bullet.height * scaleY > barrier.y) {
                        
                        // Calculate hit pixel in barrier's local coordinates
                        const pixelSizeX = barrier.width / barrierPixelGridWidth;
                        const pixelSizeY = barrier.height / barrierPixelGridHeight;

                        let hitX = (bullet.x + bullet.width * scaleX / 2) - barrier.x;
                        let hitY = (bullet.y + bullet.height * scaleY / 2) - barrier.y;

                        // Convert to pixel map indices
                        let hitCol = Math.floor(hitX / pixelSizeX);
                        let hitRow = Math.floor(hitY / pixelSizeY);

                        // Ensure indices are within bounds
                        hitCol = Math.max(0, Math.min(hitCol, barrierPixelGridWidth - 1));
                        hitRow = Math.max(0, Math.min(hitRow, barrierPixelGridHeight - 1));

                        // "Destroy" a small area around the hit point
                        for (let r = -barrierDestructionRadius; r <= barrierDestructionRadius; r++) {
                            for (let c = -barrierDestructionRadius; c <= barrierDestructionRadius; c++) {
                                const targetRow = hitRow + r;
                                const targetCol = hitCol + c;
                                if (targetRow >= 0 && targetRow < barrierPixelGridHeight &&
                                    targetCol >= 0 && targetCol < barrierPixelGridWidth) {
                                    barrier.pixelMap[targetRow][targetCol] = 0; // Mark as destroyed
                                }
                            }
                        }
                        bullets.splice(bulletIndex, 1); // Remove bullet
                        bulletOnScreen = false; // Bullet removed, can shoot again

                        // Check if barrier is completely destroyed (no more '1's in pixelMap)
                        const isBarrierDestroyed = barrier.pixelMap.every(row => row.every(pixel => pixel === 0));
                        if (isBarrierDestroyed) {
                            barriers.splice(barrierIndex, 1); // Remove barrier from array
                        }
                    }
                });

                // Player bullets vs UFO
                if (ufo.alive &&
                    bullet.x < ufo.x + ufo.width &&
                    bullet.x + bullet.width * scaleX > ufo.x &&
                    bullet.y < ufo.y + ufo.height &&
                    bullet.y + bullet.height * scaleY > ufo.y) {
                    
                    bullets.splice(bulletIndex, 1); // Remove bullet
                    bulletOnScreen = false; // Bullet removed, can shoot again
                    ufo.alive = false; // Destroy UFO
                    score += ufo.points; // Add UFO points
                    try {
                        explodeSynth.triggerAttackRelease('8n'); // Play explosion sound for UFO
                        // Use ufoPlayer if available, otherwise ufoSynth
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } catch (e) {
                        console.log('UFO explosion sound playback failed:', e);
                    }
                }
            });

            // Alien bombs vs Player
            bombs.forEach((bomb, bombIndex) => {
                if (!player.isHit && // Only hit if not invincible
                    bomb.x < player.x + player.width &&
                    bomb.x + bomb.width * scaleX > player.x &&
            bomb.y < player.y + player.height &&
                    bomb.y + bomb.height * scaleY > player.y) {
                    
                    bombs.splice(bombIndex, 1); // Remove bomb
                    player.lives--;
                    player.isHit = true;
                    player.hitTimer = player.hitDuration; // Start invincibility timer

                    if (player.lives <= 0) {
                        // Player died, start death timer
                        explodeSynth.triggerAttackRelease('8n'); // Play explosion sound
                        playerDeathTimer = 90; // Approx 1.5 seconds pause (90 frames at 60fps)
                    } else {
                        // Player hit, but not game over yet. Reset player position, clear bombs.
                        player.x = canvas.width / 2 - player.width / 2;
                        bombs.length = 0;
                    }
                    return; // Exit early to prevent multiple hits from one bomb
                }

                // Alien bombs vs Barriers
                barriers.forEach((barrier, barrierIndex) => {
                    if (bomb.x < barrier.x + barrier.width &&
                        bomb.x + bomb.width * scaleX > barrier.x &&
                        bomb.y < barrier.y + barrier.height &&
                        bomb.y + bomb.height * scaleY > barrier.y) {
                        
                        // Calculate hit pixel in barrier's local coordinates
                        const pixelSizeX = barrier.width / barrierPixelGridWidth;
                        const pixelSizeY = barrier.height / barrierPixelGridHeight;

                        let hitX = (bomb.x + bomb.width * scaleX / 2) - barrier.x;
                        let hitY = (bomb.y + bomb.height * scaleY / 2) - barrier.y;

                        // Convert to pixel map indices
                        let hitCol = Math.floor(hitX / pixelSizeX);
                        let hitRow = Math.floor(hitY / pixelSizeY);

                        // Ensure indices are within bounds
                        hitCol = Math.max(0, Math.min(hitCol, barrierPixelGridWidth - 1));
                        hitRow = Math.max(0, Math.min(hitRow, barrierPixelGridHeight - 1));

                        // "Destroy" a small area around the hit point
                        for (let r = -barrierDestructionRadius; r <= barrierDestructionRadius; r++) {
                            for (let c = -barrierDestructionRadius; c <= barrierDestructionRadius; c++) {
                                const targetRow = hitRow + r;
                                const targetCol = hitCol + c;
                                if (targetRow >= 0 && targetRow < barrierPixelGridHeight &&
                                    targetCol >= 0 && targetCol < barrierPixelGridWidth) {
                                    barrier.pixelMap[targetRow][targetCol] = 0; // Mark as destroyed
                                }
                            }
                        }
                        bombs.splice(bombIndex, 1); // Remove bomb

                        // Check if barrier is completely destroyed (no more '1's in pixelMap)
                        const isBarrierDestroyed = barrier.pixelMap.every(row => row.every(pixel => pixel === 0));
                        if (isBarrierDestroyed) {
                            barriers.splice(barrierIndex, 1); // Remove barrier from array
                        }
                    }
                });
            });
        }

        // Update game
        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars(); // Draw stars first for background

            if (!gameStarted) {
                drawStartScreen();
                animationFrameId = requestAnimationFrame(update);
                return;
            }

            if (gameOver) {
                ctx.fillStyle = '#00ff00';
                ctx.font = `${40 * scaleY}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.fillText(`SCORE: ${score}`, canvas.width / 2, canvas.height / 2 + 48 * scaleY);
                ctx.fillText('Press Enter to Reset', canvas.width / 2, canvas.height / 2 + 96 * scaleY);
                ctx.textAlign = 'left';
                cancelAnimationFrame(animationFrameId); // Stop the game loop
                return;
            }

            // Handle pause logic
            if (gamePaused) {
                drawPlayer();
                drawBullets();
                drawBombs();
                drawAliens();
                drawBarriers();
                drawUFO();
                drawScore(); // Draw score and "PAUSED" message
                animationFrameId = requestAnimationFrame(update); // Keep requesting frames to show PAUSED message
                return; // Skip all game logic if paused
            }

            // Handle player death pause
            if (playerDeathTimer > 0) {
                playerDeathTimer--;
                if (playerDeathTimer === 0) {
                    gameOver = true; // Transition to game over after pause
                }
                // Only draw, do not move or check collisions during pause
                drawPlayer();
                drawBullets();
                drawBombs();
                drawAliens();
                drawBarriers();
                drawUFO();
                drawScore();
                animationFrameId = requestAnimationFrame(update);
                return; // Skip normal game logic
            }

            // Update explosion timers for aliens
            aliens.forEach(alien => {
                if (alien.isExploding) {
                    alien.explosionTimer--;
                    // Alien is removed from drawing once explosion timer hits 0
                }
            });

            // Update alien animation frame
            alienAnimationTimer--;
            if (alienAnimationTimer <= 0) {
                alienAnimationFrame = 1 - alienAnimationFrame; // Toggle between 0 and 1
                alienAnimationTimer = 15; // Reset timer
            }


            if (aliensAliveCount === 0) {
                // Win condition - start next wave
                score += 100; // Bonus for clearing wave
                baseAlienSpeed *= 1.1; // Make next wave slightly faster
                initAliens(); // Start a new wave of aliens
                bullets.length = 0;
                bombs.length = 0;
                bulletOnScreen = false; // Reset bullet state
                ufo.alive = false; // Ensure UFO is gone
                ufoSpawnTimer = ufoSpawnInterval; // Reset UFO timer for new wave
            }

            // Update high score
            if (score > highScore) {
                highScore = score;
            }

            // Player hit timer
            if (player.isHit) {
                player.hitTimer--;
                if (player.hitTimer <= 0) {
                    player.isHit = false;
                }
            }

            movePlayer();
            moveBullets();
            moveBombs();
            dropBombs();
            moveAliens();
            moveUFO(); // Move UFO
            checkCollisions();
            drawPlayer();
            drawBullets();
            drawBombs();
            drawAliens();
            drawBarriers();
            drawUFO(); // Draw UFO
            drawScore();

            animationFrameId = requestAnimationFrame(update);
        }

        // Controls
        document.addEventListener('keydown', e => {
            e.preventDefault(); // Prevent browser default behavior for arrow keys and space
            if (e.key === 'Enter') {
                resetGame(); // Reset game immediately on Enter
                return;
            }

            // Only allow pause/unpause if game has started and not game over or in death pause
            if (e.key === 'p' || e.key === 'P') { // 'P' key for pause/resume
                if (gameStarted && !gameOver && playerDeathTimer <= 0) {
                    gamePaused = !gamePaused;
                    if (gamePaused) {
                        // Stop UFO sound if paused
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } else {
                        // Resume UFO sound if unpaused and UFO is alive
                        if (ufo.alive) {
                            if (ufoPlayer) { ufoPlayer.start(); }
                            else if (ufoSynth) { ufoSynth.start(); }
                        }
                    }
                }
                return; // Consume 'p' event
            }

            if (!gameStarted || gameOver || playerDeathTimer > 0 || gamePaused) {
                // If game not started, over, in death pause, or paused, ignore other controls
                return;
            }

            if (e.key === 'ArrowLeft') player.dx = -player.speed;
            if (e.key === 'ArrowRight') player.dx = player.speed;
            if (e.key === ' ' && canShoot && !bulletOnScreen) { // Spacebar for shooting
                bullets.push({
                    x: player.x + player.width / 2 - bulletWidth * scaleX / 2,
                    y: player.y - bulletHeight * scaleY,
                    width: bulletWidth,
                    height: bulletHeight
                });
                try {
                    // Play shoot sound using Tone.Player if available, else synthesized
                    if (shootPlayer) { shootPlayer.start(); }
                    else if (synthesizedShootSynth) { synthesizedShootSynth.triggerAttackRelease('C4', '16n'); }
                } catch (e) {
                    console.log('Shoot sound playback failed:', e);
                }
                canShoot = false;
                bulletOnScreen = true; // Set bullet on screen flag
                setTimeout(() => {
                    canShoot = true;
                }, shootCooldown);
            }
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') player.dx = 0;
        });

        // Mobile Touch Controls
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted || gameOver || playerDeathTimer > 0 || gamePaused) return;
            player.dx = -player.speed;
        });
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.dx = 0;
        });

        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted || gameOver || playerDeathTimer > 0 || gamePaused) return;
            player.dx = player.speed;
        });
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.dx = 0;
        });

        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted || gameOver || !canShoot || bulletOnScreen || playerDeathTimer > 0 || gamePaused) return;
            bullets.push({
                x: player.x + player.width / 2 - bulletWidth * scaleX / 2,
                y: player.y - bulletHeight * scaleY,
                width: bulletWidth,
                height: bulletHeight
            });
            try {
                // Play shoot sound using Tone.Player if available, else synthesized
                if (shootPlayer) { shootPlayer.start(); }
                else if (synthesizedShootSynth) { synthesizedShootSynth.triggerAttackRelease('C4', '16n'); }
            } catch (e) {
                console.log('Shoot sound playback failed:', e);
            }
            canShoot = false;
            bulletOnScreen = true; // Set bullet on screen flag
            setTimeout(() => {
                canShoot = true;
            }, shootCooldown);
        });

        // Initialize and start the game
        window.onload = () => {
            resizeCanvas(); // Set initial canvas size and scale factors
            setupAudio(); // Initialize Tone.js synths
            update(); // Start the game loop (will display start screen)
        };

        window.addEventListener('resize', () => {
            resizeCanvas();
            // If game is active, resume animation
            if (gameStarted && !gameOver) {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                update();
            } else if (!gameStarted || gameOver) {
                // If on start/game over screen, just redraw it
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!gameStarted) drawStartScreen();
                else if (gameOver) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = `${40 * scaleY}px 'Press Start 2P'`;
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                    ctx.fillText(`SCORE: ${score}`, canvas.width / 2, canvas.height / 2 + 48 * scaleY);
                    ctx.fillText('Press Enter to Reset', canvas.width / 2, canvas.height / 2 + 96 * scaleY);
                    ctx.textAlign = 'left';
                }
            }
        });

    </script>
</body>
</html>

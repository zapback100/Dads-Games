<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Space Invaders</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            background: #000;
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: 'Press Start 2P', cursive; /* Retro font */
            color: #fff;
        }
        canvas {
            /* Removed border: 2px solid #fff; */
            background: #000;
            image-rendering: pixelated;
            max-width: 95vw; /* Ensure canvas fits wider screens */
            max-height: 80vh; /* Ensure canvas fits taller screens */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }
        .control-button {
            background-color: #00ff00;
            color: #000;
            border: 2px solid #00aa00;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.1s, transform 0.1s;
            box-shadow: 0 5px #00aa00;
            user-select: none; /* Prevent text selection on touch */
            font-family: 'Press Start 2P', cursive;
        }
        .control-button:active {
            background-color: #00cc00;
            transform: translateY(2px);
            box-shadow: 0 3px #00aa00;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ff00;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            font-family: 'Press Start 2P', cursive;
            color: #00ff00;
            display: none; /* Hidden by default */
            z-index: 1000;
        }
        .message-box button {
            background-color: #00ff00;
            color: #000;
            border: 2px solid #00aa00;
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Press Start 2P', cursive;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="controls" id="mobileControls">
        <button class="control-button" id="leftButton">←</button>
        <button class="control-button" id="shootButton">FIRE</button>
        <button class="control-button" id="rightButton">→</button>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageButton">OK</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const mobileControls = document.getElementById('mobileControls');
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const shootButton = document.getElementById('shootButton');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const messageButton = document.getElementById('messageButton');

        // Game scaling factor (based on original 800x600)
        let scaleX = 1;
        let scaleY = 1;

        // How many canvas pixels one original game pixel represents
        const GAME_PIXEL_MAGNIFICATION = 2; // Each original pixel is rendered as 2x2 canvas pixels

        // Player
        const player = {
            x: 0, // Will be set dynamically
            y: 0, // Will be set dynamically
            width: 13 * GAME_PIXEL_MAGNIFICATION, // Original player width is 13 pixels (updated)
            height: 8 * GAME_PIXEL_MAGNIFICATION, // Original player height is 8 pixels (updated)
            speed: 7, // Increased player speed for more responsiveness
            dx: 0,
            lives: 3,
            isExploding: false, // True when explosion animation is active
            explosionFrameCounter: 0, // Counts frames for explosion animation
            explosionStateDuration: 10, // Frames for each explosion visual state (e.g., 10 frames per pattern/blank)
            explosionTotalDuration: 40, // Total frames for the full explosion sequence (4 states * 10 frames/state)
            isInvincible: false, // True during invincibility period after respawn
            invincibilityTimer: 0, // Timer for invincibility period
            invincibilityDuration: 120 // Frames of invincibility (flashing)
        };

        // Player Bullets
        const bullets = [];
        const bulletSpeed = 7; // Remains at 7, within 4-8px/frame
        const PLAYER_BULLET_WIDTH_ORIG = 1; // Original player bullet width is 1 pixel
        const PLAYER_BULLET_HEIGHT_ORIG = 4; // Original player bullet height is 4 pixels
        let canShoot = true; // Controls player shooting cooldown
        let bulletOnScreen = false; // Controls one bullet at a time
        const shootCooldown = 120; // milliseconds - FASTER GUN

        // Alien Bombs (now animated alien bullets)
        const bombs = [];
        const bombSpeed = 2; // Adjusted for slower bombs
        const ALIEN_BULLET_WIDTH_ORIG = 3; // Original alien bullet width is 3 pixels
        const ALIEN_BULLET_HEIGHT_ORIG = 8; // Original alien bullet height is 8 pixels
        const bombDropChance = 0.001; // Decreased chance for fewer bombs

        // Aliens
        const aliens = []; // This array holds all alien objects
        const alienRows = 5;
        const alienCols = 11;

        // Original pixel dimensions from game's internal logic/sprites
        const ALIEN_SPRITE_WIDTH_10_20_PTS_ORIG = 11; // Based on pixel map width for Crab/Octopus
        const ALIEN_SPRITE_WIDTH_30_PTS_ORIG = 12; // Based on pixel map width for Squid
        const ALIEN_SPRITE_HEIGHT_ORIG = 8; // Based on pixel map height for all aliens

        // Original pixel spacing values
        const ALIEN_HORIZONTAL_GAP_ORIG = 8; // As per user's "8 pixels" gap
        const ALIEN_VERTICAL_GAP_ORIG = 8; // As per user's "8-10 pixels" and vertical drop
        const ALIEN_VERTICAL_DROP_ORIG = 8; // As per user's "8 pixels down per event"

        // Alien movement step size (fixed 2 pixels per step, original)
        const alienStep_ORIG = 2; 
        let alienDirection = 1; // 1 for right, -1 for left

        // Global formation position (top-left of the entire formation)
        let formationBaseX = 0;
        let formationBaseY = 0;

        let aliensAliveCount = 0;
        let totalAliens = alienRows * alienCols;

        // Alien Animation and Movement Timing
        let alienAnimationFrame = 0; // 0 or 1
        let alienAnimationTimer = 15; // Frames before switching animation frame (slower animation)

        let alienMoveTimer = 0; // Timer for alien movement steps
        const initialAlienMoveInterval = 40; // Adjusted for faster initial alien movement
        const minAlienMoveInterval = 5; // Minimum frames for alien move (faster, ~5 interrupts)
        let currentAlienMoveInterval = initialAlienMoveInterval; // Current interval

        // For wave-like, desynchronized alien motion
        let tickCounter = 0; // Counts frames within the current movement interval
        const wavePhases = [0, 2, 4, 6, 8]; // Delay each row's move by frames. Max value should be less than minAlienMoveInterval.


        // Alien Sprites (pixel maps) - Frame 1
        const alien10PtsMap_frame1 = [ // Crab - 11x8 original pixels
            [0,0,0,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,1,0,1,1,1,1,1,0,1,1], 
            [1,0,1,1,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,1,0,1],
            [0,1,0,1,1,0,1,1,0,1,0] // Legs spread
        ];
        // Alien Sprites (pixel maps) - Frame 2 (legs together)
        const alien10PtsMap_frame2 = [
            [0,0,0,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,1,0,1,1,1,1,1,0,1,1], 
            [1,0,1,1,1,1,1,1,1,0,1],
            [0,1,0,1,1,0,1,1,0,1,0], // Legs together
            [1,0,1,0,0,0,0,0,1,0,1]
        ];

        // Medium Invader (Octopus-like) - 11x8 original pixels - Frame 1
        const alien20PtsMap_frame1 = [ 
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,0,0,1,0,0,0,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,0],
            [0,1,0,1,0,1,0,1,0,1,0], // Legs spread
            [1,0,1,0,1,0,1,0,1,0,1]
        ];
        // Medium Invader (Octopus-like) - 11x8 original pixels - Frame 2
        const alien20PtsMap_frame2 = [ 
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,0,0,1,0,0,0,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,1,1,0],
            [1,0,1,0,1,0,1,0,1,0,1], // Legs together
            [0,1,0,1,0,1,0,1,0,1,0]
        ];

        // Small Invader (Squid-like) - 12x8 original pixels - Frame 1
        const alien30PtsMap_frame1 = [ 
            [0,0,0,0,1,1,1,1,0,0,0,0], 
            [0,0,0,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [0,1,0,1,0,1,0,1,0,1,0,1], // Legs spread
            [1,0,1,0,1,0,1,0,1,0,1,0]
        ];
        // Small Invader (Squid-like) - 12x8 original pixels - Frame 2
        const alien30PtsMap_frame2 = [ 
            [0,0,0,0,1,1,1,1,0,0,0,0], 
            [0,0,0,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,1,1,1,1,1,1,1,0,0],
            [1,0,1,0,1,0,1,0,1,0,1,0], // Legs together
            [0,1,0,1,0,1,0,1,0,1,0,1]
        ];


        // Alien Explosion Sprite (8x8 pixels)
        const ALIEN_EXPLOSION_PATTERN = [
            [0,1,0,0,0,0,1,0],
            [1,1,1,0,0,1,1,1],
            [1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,0],
            [0,0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0,0],
            [0,0,0,0,1,0,0,0],
            [0,0,0,0,0,0,0,0],
        ];
        const ALIEN_EXPLOSION_DURATION = 2; // Show for 2 frames, then disappear (e.g., frame 0 and frame 1 visible)

        // Player Bullet Sprite (1x4 pixels)
        const playerBulletSprite = [
            [1],
            [1],
            [1],
            [1],
        ];

        // Alien Bullet Frames (3x8 matrices, 2 frames for zigzag)
        const alienBulletFrames = [
            [ // Frame 0: Zigzag
                [0,1,0],
                [1,0,1],
                [0,1,0],
                [1,0,1],
                [0,1,0],
                [1,0,1],
                [0,1,0],
                [1,0,1]
            ],
            [ // Frame 1: Zigzag (offset)
                [1,0,1],
                [0,1,0],
                [1,0,1],
                [0,1,0],
                [1,0,1],
                [0,1,0],
                [1,0,1],
                [0,1,0]
            ]
        ];
        const ALIEN_BULLET_ANIMATION_SPEED = 5; // Update alien bullet frame every 5 ticks


        // Barriers
        const barriers = [];
        const BARRIER_PIXEL_WIDTH_ORIG = 32; // Updated to 32x32 pixels as per spec
        const BARRIER_PIXEL_HEIGHT_ORIG = 32; // Updated to 32x32 pixels as per spec
        const barrierDestructionRadius = 2; // Increased radius for more noticeable damage (user suggested "small groups")

        // SHIELD TEMPLATE (22x16 pixels - based on user's provided pattern and common arcade patterns)
        const SHIELD_PIXEL_TEMPLATE = [
            [0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0], // Top crenelation
            [0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1], // Bottom notches
            [1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1]  // More bottom notches
        ];

        const MASK_W = SHIELD_PIXEL_TEMPLATE[0].length; // 22
        const MASK_H = SHIELD_PIXEL_TEMPLATE.length;    // 16
        // Calculate offsets to center the 22x16 mask within the 32x32 barrier slot
        const OFFSET_X_ORIG = Math.floor((BARRIER_PIXEL_WIDTH_ORIG - MASK_W) / 2); // (32-22)/2 = 5
        const OFFSET_Y_ORIG = 8; // 8 original pixels down from top of 32x32 slot (as per user's "UNIT" suggestion)

        // Explosion patterns (8x8) - Moved here to be defined before UFO uses them
        const explosionPattern1 = [
            [0,1,0,0,0,0,1,0],
            [0,0,1,0,0,1,0,0],
            [1,0,0,1,1,0,0,1],
            [0,0,1,0,0,1,0,0],
            [0,1,0,0,0,0,1,0],
            [0,0,1,0,0,1,0,0],
            [1,0,0,1,1,0,0,1],
            [0,0,1,0,0,1,0,0]
        ];

        const explosionPattern2 = [
            [1,0,0,0,0,0,0,1],
            [0,1,0,0,0,0,1,0],
            [0,0,1,0,0,1,0,0],
            [0,0,0,1,1,0,0,0],
            [0,0,0,1,1,0,0,0],
            [0,0,1,0,0,1,0,0],
            [0,1,0,0,0,0,1,0],
            [1,0,0,0,0,0,0,1]
        ];

        const blankPattern = [
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0,0]
        ];

        // UFO
        const ufo = {
            x: 0,
            // UFO Y position: around Y = 32 px (original pixels)
            y: 32 * GAME_PIXEL_MAGNIFICATION, // Position at the top, adjusted for scale
            width: 16 * GAME_PIXEL_MAGNIFICATION, // Original UFO width is 16 pixels
            height: 7 * GAME_PIXEL_MAGNIFICATION, // Original UFO height is 7 pixels
            speed: 1.5, // Remains at 1.5, within 1-2px/frame
            alive: false,
            direction: 1, // 1 for right, -1 for left
            points: 250, // Updated to 250 points for shooting UFO
            exploding: false, // NEW: Explosion state for UFO
            explosionTick: 0 // NEW: Explosion animation tick for UFO
        };
        // UFO pixel map based on image_886d9e.png (16x7 pixels)
        const ufoPixelMap = [
            [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // Bottom "legs"
        ];
        // UFO Explosion Frames (reusing player explosion patterns for simplicity as no specific UFO pattern was given)
        const ufoExplosionFrames = [
            explosionPattern1, // Frame 1 (8x8)
            explosionPattern2  // Frame 2 (8x8)
        ];
        const UFO_EXPLOSION_STATE_DURATION = 10; // Frames per explosion pattern state for UFO
        const UFO_EXPLOSION_TOTAL_DURATION = UFO_EXPLOSION_STATE_DURATION * ufoExplosionFrames.length;


        let ufoSpawnTimer = 0;
        const ufoSpawnInterval = 1000; // Minimum frames between UFO spawns (approx 16 seconds)

        // Game state
        let score = 0;
        let highScore = 0; // New: High Score variable
        let gameOver = false;
        let gameStarted = false;
        let gamePaused = false; // New: Game paused state
        let animationFrameId;
        let playerDeathTimer = 0; // Timer for player death pause

        // Starfield
        const stars = [];
        const numStars = 100;

        // Tone.js Synths for sound effects
        let shootSynth, explodeSynth, bombSynth;

        // Alien movement sound
        let invaderMoveSynth;
        const invaderMoveNotes = ['C3', 'B2', 'A#2', 'A2']; // Chromatic descending pattern
        let currentNoteIndex = 0; // To keep track of the note in the sequence

        // Global AudioContext for Web Audio API
        let audioCtx;

        // --- Sound Configurations ---
        const ufoSoundUrl = 'https://raw.githubusercontent.com/zapback100/Dads-Games/Space/ufo_lowpitch.wav';
        const shootSoundUrl = 'https://cdn.jsdelivr.net/gh/zapback100/Dads-Games/shoot.wav'; 
        // Corrected invader killed sound URL to use jsDelivr for CORS compatibility
        const invaderKilledSoundUrl = 'https://cdn.jsdelivr.net/gh/zapback100/Dads-Games/invaderkilled.wav'; 
        const playerExplosionSoundUrl = 'https://cdn.jsdelivr.net/gh/zapback100/Dads-Games/explosion.wav'; // New player explosion sound URL
        const ufoExplosionSoundUrl = 'https://cdn.jsdelivr.net/gh/zapback100/Dads-Games/16-ufo-down-101soundboards.mp3'; // New UFO explosion sound URL

        let ufoPlayer = null; 
        let ufoSynth = null; 
        let shootPlayer = null; 
        let synthesizedShootSynth = null; 
        let invaderKilledPlayer = null; 
        let synthesizedInvaderKilledSynth = null; 
        let playerExplosionPlayer = null; // New player explosion sound player
        let ufoExplosionPlayer = null; // New UFO explosion sound player

        function setupAudio() {
            // Initialize Tone.js context
            Tone.start();
            audioCtx = new (window.AudioContext || window.webkitAudioContext)(); // Initialize global AudioContext

            // Player shoot sound
            // Prioritize external URL, fallback to synthesized
            if (shootSoundUrl) {
                shootPlayer = new Tone.Player({
                    url: shootSoundUrl,
                    autostart: false,
                    volume: -10 
                }).toDestination();

                shootPlayer.onerror = (e) => {
                    console.error("Error loading shoot sound:", e);
                    shootPlayer = null; 
                    synthesizedShootSynth = new Tone.Synth({
                        oscillator: { type: "square" },
                        envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
                    }).toDestination();
                    console.warn("Falling back to synthesized shoot sound.");
                };
            } else {
                synthesizedShootSynth = new Tone.Synth({
                    oscillator: { type: "square" },
                    envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }
                }).toDestination();
            }

            // Invader killed sound
            if (invaderKilledSoundUrl) {
                invaderKilledPlayer = new Tone.Player({
                    url: invaderKilledSoundUrl,
                    autostart: false,
                    volume: -10 
                }).toDestination();

                invaderKilledPlayer.onerror = (e) => {
                    console.error("Error loading invader killed sound:", e);
                    invaderKilledPlayer = null;
                    synthesizedInvaderKilledSynth = new Tone.NoiseSynth({
                        noise: { type: "white" },
                        envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2 }
                    }).toDestination();
                    console.warn("Falling back to synthesized invader killed sound.");
                };
            } else {
                synthesizedInvaderKilledSynth = new Tone.NoiseSynth({
                    noise: { type: "white" },
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.2 }
                }).toDestination();
            }

            // Player explosion sound
            if (playerExplosionSoundUrl) {
                playerExplosionPlayer = new Tone.Player({
                    url: playerExplosionSoundUrl,
                    autostart: false,
                    volume: -5 // Slightly louder for player death
                }).toDestination();

                playerExplosionPlayer.onerror = (e) => {
                    console.error("Error loading player explosion sound:", e);
                    playerExplosionPlayer = null;
                    // Fallback to general explodeSynth if specific player explosion sound fails
                    console.warn("Falling back to synthesized explosion sound for player death.");
                };
            } else {
                // If no URL provided, just use the general explodeSynth
                playerExplosionPlayer = null;
            }

            // UFO Explosion Sound - NEW
            if (ufoExplosionSoundUrl) {
                ufoExplosionPlayer = new Tone.Player({
                    url: ufoExplosionSoundUrl,
                    autostart: false,
                    volume: -5 // Adjust volume as needed
                }).toDestination();
                ufoExplosionPlayer.onerror = (e) => {
                    console.error("Error loading UFO explosion sound:", e);
                    ufoExplosionPlayer = null;
                    console.warn("Falling back to synthesized UFO explosion sound.");
                };
            } else {
                ufoExplosionPlayer = null;
            }


            // Alien explosion sound (used for UFO) - kept as NoiseSynth
            explodeSynth = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: {
                    attack: 0.001,
                    decay: 0.2,
                    sustain: 0.01,
                    release: 0.2
                }
            }).toDestination();

            // Alien bomb drop sound
            bombSynth = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 8,
                oscillator: { type: "sine" },
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0.01,
                    release: 0.4
                }
            }).toDestination();

            // Initialize UFO sound based on whether a URL is provided
            if (ufoSoundUrl) {
                ufoPlayer = new Tone.Player({
                    url: ufoSoundUrl,
                    loop: true, 
                    autostart: false,
                    volume: -10 
                }).toDestination();

                ufoPlayer.onerror = (e) => {
                    console.error("Error loading UFO sound:", e);
                    ufoPlayer = null; 
                    ufoSynth = new Tone.PulseOscillator('A3', 0.2).toDestination();
                    ufoSynth.volume.value = -10;
                    console.warn("Falling back to synthesized UFO sound.");
                };
            } else {
                ufoSynth = new Tone.PulseOscillator('A3', 0.2).toDestination(); 
                ufoSynth.volume.value = -10; 
            }

            // Invader movement sound synth (square wave for classic sound)
            invaderMoveSynth = new Tone.Synth({
                oscillator: { type: "square" },
                envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.05 }
            }).toDestination();
        }

        // Function to play UFO explosion sound (code-generated, improved version)
        function playUfoExplosionSound() {
            // First, try to play the specific UFO explosion sound if loaded
            if (ufoExplosionPlayer) {
                ufoExplosionPlayer.start();
                return; // Play the loaded sound and exit
            }

            // Fallback to synthesized sound if the specific sound is not available
            const duration = 0.25;

            // Create white noise
            const bufferSize = audioCtx.sampleRate * duration;
            const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = noiseBuffer;

            // Create bandpass filter with descending frequency
            const filter = audioCtx.createBiquadFilter();
            filter.type = "bandpass";
            filter.frequency.setValueAtTime(1800, audioCtx.currentTime);
            filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + duration);

            // Volume envelope
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);

            // Connect and play
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
            noise.stop(audioCtx.currentTime + duration);
        }


        // Show custom message box
        function showMessageBox(message, buttonText = "OK", callback = null) {
            messageText.textContent = message;
            messageButton.textContent = buttonText;
            messageBox.style.display = 'block';
            messageButton.onclick = () => {
                messageBox.style.display = 'none';
                if (callback) callback();
            };
        }

        // Initialize stars for background
        function initStars() {
            stars.length = 0;
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.5 + 0.5,
                    alpha: Math.random()
                });
            }
        }

        // Draw stars
        function drawStars() {
            ctx.fillStyle = '#fff';
            stars.forEach(star => {
                ctx.globalAlpha = star.alpha;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                ctx.fill();
                star.y += 0.1; // Slowly move stars down
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
            ctx.globalAlpha = 1.0;
        }

        // Initialize aliens
        function initAliens() {
            aliens.length = 0;
            aliensAliveCount = 0;
            totalAliens = alienRows * alienCols;

            // Calculate initial starting position for the formation's top-left
            const maxAlienWidthForLayout_ORIG = ALIEN_SPRITE_WIDTH_30_PTS_ORIG; 
            const formationInternalWidth_ORIG = alienCols * (maxAlienWidthForLayout_ORIG + ALIEN_HORIZONTAL_GAP_ORIG) - ALIEN_HORIZONTAL_GAP_ORIG; 
            
            // Set initial formationBaseX and formationBaseY
            formationBaseX = (canvas.width - (formationInternalWidth_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX)) / 2;
            formationBaseY = 80 * scaleY; 

            for (let row = 0; row < alienRows; row++) {
                for (let col = 0; col < alienCols; col++) {
                    let alienPixelMap1, alienPixelMap2;
                    let alienSpriteWidth_ORIG; 
                    let points;

                    // Assign different alien types based on row and their corresponding points
                    if (row === 0) { // Top row (Squid-like)
                        alienPixelMap1 = alien30PtsMap_frame1; 
                        alienPixelMap2 = alien30PtsMap_frame2;
                        alienSpriteWidth_ORIG = ALIEN_SPRITE_WIDTH_30_PTS_ORIG;
                        points = 30; 
                    } else if (row === 1 || row === 2) { // Middle two rows (Octopus-like)
                        alienPixelMap1 = alien20PtsMap_frame1; 
                        alienPixelMap2 = alien20PtsMap_frame2;
                        alienSpriteWidth_ORIG = ALIEN_SPRITE_WIDTH_10_20_PTS_ORIG;
                        points = 20; 
                    } else { // Bottom two rows (Crab-like)
                        alienPixelMap1 = alien10PtsMap_frame1; 
                        alienPixelMap2 = alien10PtsMap_frame2;
                        alienSpriteWidth_ORIG = ALIEN_SPRITE_WIDTH_10_20_PTS_ORIG;
                        points = 10; 
                    }

                    aliens.push({
                        gridCol: col, 
                        gridRow: row,
                        width: alienSpriteWidth_ORIG * GAME_PIXEL_MAGNIFICATION, 
                        height: ALIEN_SPRITE_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION, 
                        pixelMap_frame1: alienPixelMap1, 
                        pixelMap_frame2: alienPixelMap2,
                        alive: true,
                        health: 1, 
                        isExploding: false, 
                        explosionTimer: 0, 
                        points: points 
                    });
                    aliensAliveCount++;
                }
            }
            // Reset movement state for new wave
            currentAlienToMoveIndex = 0; // This is now less relevant as movement is block-wise
            aliensMovedInCurrentCycle = 0; // This is now less relevant as movement is block-wise
        }

        // Initialize barriers
        function initBarriers() {
            barriers.length = 0;
            
            // Positioning constants based on original game layout (using original pixel values)
            // Top of shield is 168 original pixels from top (200 - 32)
            const SHIELD_Y_ORIG = 200 - BARRIER_PIXEL_HEIGHT_ORIG; 

            // Calculate barrier dimensions in canvas pixels
            const barrierWidth = BARRIER_PIXEL_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX; 
            const barrierHeight = BARRIER_PIXEL_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY; 

            // Calculate barrier Y position in canvas pixels
            const barrierY = SHIELD_Y_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY;

            const numBarriers = 4;
            // Calculate total width of barriers including spacing for even distribution
            const totalBarriersRenderedWidth = numBarriers * barrierWidth;
            const totalHorizontalSpace = canvas.width;
            const spacingBetweenBarriers = (totalHorizontalSpace - totalBarriersRenderedWidth) / (numBarriers + 1); // Distribute evenly with padding on ends

            for (let i = 0; i < numBarriers; i++) {
                // Initialize a 32x32 pixel map for each barrier, all zeros initially
                const newPixelMap = Array(BARRIER_PIXEL_HEIGHT_ORIG).fill(0).map(() => Array(BARRIER_PIXEL_WIDTH_ORIG).fill(0));

                // Stamp the SHIELD_PIXEL_TEMPLATE onto the newPixelMap with offsets
                for (let row = 0; row < MASK_H; row++) {
                    for (let col = 0; col < MASK_W; col++) {
                        if (SHIELD_PIXEL_TEMPLATE[row][col] === 1) {
                            const targetRow = row + OFFSET_Y_ORIG;
                            const targetCol = col + OFFSET_X_ORIG;
                            if (targetRow >= 0 && targetRow < BARRIER_PIXEL_HEIGHT_ORIG &&
                                targetCol >= 0 && targetCol < BARRIER_PIXEL_WIDTH_ORIG) {
                                newPixelMap[targetRow][targetCol] = 1;
                            }
                        }
                    }
                }

                barriers.push({
                    x: spacingBetweenBarriers + i * (barrierWidth + spacingBetweenBarriers),
                    y: barrierY,
                    width: barrierWidth,
                    height: barrierHeight,
                    pixelMap: newPixelMap // Use the newly created pixel map
                });
            }
        }

        // Reset game state
        function resetGame() {
            // Player Y adjusted to be above the green line
            player.y = (canvas.height - 40 * scaleY) - (player.height * scaleY) - (2 * scaleY); 
            player.x = canvas.width / 2 - (player.width * scaleX) / 2;
            player.lives = 3;
            score = 0;
            gameOver = false;
            gameStarted = true;
            gamePaused = false; // Ensure game is not paused on reset
            bullets.length = 0;
            bombs.length = 0;
            alienDirection = 1;
            // Reset alien movement timing
            currentAlienMoveInterval = initialAlienMoveInterval; 
            alienMoveTimer = 0; // Reset timer
            currentNoteIndex = 0; // Reset note index for sound loop
            player.isExploding = false; // Reset explosion state
            player.explosionFrameCounter = 0; // Reset explosion frame counter
            player.isInvincible = false; // Reset invincibility state
            player.invincibilityTimer = 0; // Reset invincibility timer
            bulletOnScreen = false; // Reset bullet state
            ufo.alive = false; // Ensure UFO is not active
            ufo.exploding = false; // Reset UFO explosion state
            ufo.explosionTick = 0; // Reset UFO explosion tick
            ufoSpawnTimer = ufoSpawnInterval; // Reset UFO timer
            playerDeathTimer = 0; // Reset player death timer
            initAliens(); // Re-initialize aliens and their positions
            initBarriers();
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            update(); // Start the game loop
        }

        // Adjust canvas size and scale factors
        function resizeCanvas() {
            canvas.width = window.innerWidth * 0.95; // Use 95% of window width
            canvas.height = window.innerHeight * 0.8; // Use 80% of window height for game area

            // Ensure a minimum size to prevent elements from becoming too small
            if (canvas.width < 600) canvas.width = 600;
            if (canvas.height < 400) canvas.height = 400;

            scaleX = canvas.width / 800;
            scaleY = canvas.height / 600;

            // Re-position player and re-initialize game elements based on new scale
            // Player dimensions are fixed by GAME_PIXEL_MAGNIFICATION, scaleX/Y applies to position
            player.y = (canvas.height - 40 * scaleY) - (player.height * scaleY) - (2 * scaleY); 
            player.x = canvas.width / 2 - (player.width * scaleX) / 2;

            initAliens(); // Re-initialize aliens and their positions with new scale
            initBarriers();
            initStars();

            // Adjust mobile controls visibility based on screen width
            if (window.innerWidth < 768) { // Example breakpoint for mobile
                mobileControls.style.display = 'flex';
            } else {
                mobileControls.style.display = 'none';
            }
        }

        // Define pixel maps for start screen aliens and UFO
        const ufoStartScreenMap = [ // UFO pixel map for start screen
            [0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0],
            [0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0],
            [0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0], // Bottom "legs"
        ];

        // Helper function to draw pixel art on start screen
        function drawPixelArt(pixelMap, x, y, originalSpriteWidth, originalSpriteHeight, color) {
            ctx.fillStyle = color;
            // Calculate pixel size based on original sprite dimensions and GAME_PIXEL_MAGNIFICATION
            const pixelSizeX = (originalSpriteWidth * GAME_PIXEL_MAGNIFICATION * scaleX) / pixelMap[0].length;
            const pixelSizeY = (originalSpriteHeight * GAME_PIXEL_MAGNIFICATION * scaleY) / pixelMap.length;

            for (let row = 0; row < pixelMap.length; row++) {
                for (let col = 0; col < pixelMap[row].length; col++) {
                    if (pixelMap[row][col] === 1) {
                        ctx.fillRect(x + col * pixelSizeX, y + row * pixelSizeY, pixelSizeX, pixelSizeY);
                    }
                }
            }
        }

        // Draw start screen
        function drawStartScreen() {
            ctx.textAlign = 'center';

            // "SPACE"
            ctx.fillStyle = '#fff';
            ctx.font = `${60 * scaleY}px 'Press Start 2P'`;
            ctx.fillText('SPACE', canvas.width / 2, canvas.height / 2 - 180 * scaleY);

            // "INVADERS"
            ctx.fillStyle = '#0f0';
            ctx.font = `${60 * scaleY}px 'Press Start 2P'`;
            ctx.fillText('INVADERS', canvas.width / 2, canvas.height / 2 - 120 * scaleY);

            // Alien points section
            const startYOffset = canvas.height / 2 - 20 * scaleY;
            const lineHeight = 40 * scaleY;
            
            // 10 PTS Alien (Crab)
            drawPixelArt(alien10PtsMap_frame1, canvas.width / 2 - 100 * scaleX, startYOffset, ALIEN_SPRITE_WIDTH_10_20_PTS_ORIG, ALIEN_SPRITE_HEIGHT_ORIG, '#fff');
            ctx.fillStyle = '#fff';
            ctx.font = `${20 * scaleY}px 'Press Start 2P'`;
            ctx.textAlign = 'left';
            ctx.fillText('= 10 PTS', canvas.width / 2 - 50 * scaleX, startYOffset + (ALIEN_SPRITE_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY / 2) + 8 * scaleY);

            // 20 PTS Alien (Octopus)
            drawPixelArt(alien20PtsMap_frame1, canvas.width / 2 - 100 * scaleX, startYOffset + lineHeight, ALIEN_SPRITE_WIDTH_10_20_PTS_ORIG, ALIEN_SPRITE_HEIGHT_ORIG, '#fff');
            ctx.fillText('= 20 PTS', canvas.width / 2 - 50 * scaleX, startYOffset + lineHeight + (ALIEN_SPRITE_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY / 2) + 8 * scaleY);

            // 30 PTS Alien (Squid)
            drawPixelArt(alien30PtsMap_frame1, canvas.width / 2 - 100 * scaleX, startYOffset + 2 * lineHeight, ALIEN_SPRITE_WIDTH_30_PTS_ORIG, ALIEN_SPRITE_HEIGHT_ORIG, '#fff'); 
            ctx.fillText('= 30 PTS', canvas.width / 2 - 50 * scaleX, startYOffset + 2 * lineHeight + (ALIEN_SPRITE_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY / 2) + 8 * scaleY);

            // UFO 250 PTS
            drawPixelArt(ufoStartScreenMap, canvas.width / 2 - 100 * scaleX, startYOffset + 3 * lineHeight, ufo.width / GAME_PIXEL_MAGNIFICATION, ufo.height / GAME_PIXEL_MAGNIFICATION, '#f00');
            ctx.fillText(`= ${ufo.points} PTS`, canvas.width / 2 - 50 * scaleX, startYOffset + 3 * lineHeight + (ufo.height * scaleY / 2) + 8 * scaleY);


            // "PLAY SPACE INVADERS"
            ctx.fillStyle = '#00ff00';
            ctx.font = `${28 * scaleY}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText('PLAY SPACE INVADERS', canvas.width / 2, canvas.height - 80 * scaleY);
            ctx.textAlign = 'left'; // Reset to default
        }

        // Player Pixel Pattern (13x8) - Classic Ship
        const playerPattern = [
            [0,0,0,0,0,1,0,0,0,0,0,0,0], // Top cannon pixel
            [0,0,0,0,1,1,1,1,1,0,0,0,0], // Next row
            [0,0,0,1,1,1,1,1,1,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,1,1,0,0],
            [0,1,1,1,1,1,1,1,1,1,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1,1,1], // Main body
            [1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1]  // Base
        ];
        const playerColor = '#0f0'; // Green player ship


        // Generic function to draw a pixel pattern
        function drawPattern(ctx, pattern, x, y, pixelMagnification, color) {
            ctx.fillStyle = color;
            const patternWidth = pattern[0].length;
            const patternHeight = pattern.length;

            // Calculate the size of each "pixel" in the pattern on the canvas
            const pixelSizeX = pixelMagnification * scaleX;
            const pixelSizeY = pixelMagnification * scaleY;

            for (let row = 0; row < patternHeight; row++) {
                for (let col = 0; col < pattern[row].length; col++) {
                    if (pattern[row][col] === 1) {
                        ctx.fillRect(x + col * pixelSizeX, y + row * pixelSizeY, pixelSizeX, pixelSizeY);
                    }
                }
            }
        }

        // Draw player (retro spaceship - blocky design)
        function drawPlayer() {
            const px = player.x;
            const py = player.y;
            const pw = player.width; // Already scaled
            const ph = player.height; // Already scaled

            // Calculate center for 8x8 explosion patterns within 13x8 player area
            const explosionPatternWidth = 8; // Original pixels
            const explosionPatternHeight = 8; // Original pixels
            // Offset to center the 8x8 explosion within the 13x8 player sprite area
            const offsetX = (pw - (explosionPatternWidth * GAME_PIXEL_MAGNIFICATION * scaleX)) / 2;
            const offsetY = (ph - (explosionPatternHeight * GAME_PIXEL_MAGNIFICATION * scaleY)) / 2;


            if (player.isExploding) {
                // Determine which explosion frame to draw
                const currentExplosionStateIndex = Math.floor(player.explosionFrameCounter / player.explosionStateDuration);
                let patternToDraw;

                switch (currentExplosionStateIndex) {
                    case 0: // Explosion Frame 1
                        patternToDraw = explosionPattern1;
                        break;
                    case 1: // Blank Frame
                        patternToDraw = blankPattern;
                        break;
                    case 2: // Explosion Frame 2
                        patternToDraw = explosionPattern2;
                        break;
                    case 3: // Blank Frame
                        patternToDraw = blankPattern;
                        break;
                    default: // After the animation sequence, draw blank
                        patternToDraw = blankPattern;
                        break;
                }
                
                // Draw the explosion/blank pattern centered on the player's last known position
                // Use drawPattern with the specific pixel magnification for the explosion patterns
                drawPattern(ctx, patternToDraw, px + offsetX, py + offsetY, GAME_PIXEL_MAGNIFICATION, '#fff'); // Explosion is white

                player.explosionFrameCounter++;
                if (player.explosionFrameCounter >= player.explosionTotalDuration) {
                    player.isExploding = false; // Explosion animation finished
                    player.explosionFrameCounter = 0; // Reset counter
                    
                    if (player.lives > 0) {
                        // Respawn player
                        player.x = canvas.width / 2 - (player.width) / 2; // Reset player position
                        player.isInvincible = true;
                        player.invincibilityTimer = player.invincibilityDuration;
                    }
                }
            } else if (player.isInvincible) {
                // Player is invincible and flashing (not exploding)
                // The flashing logic: draw every other 10 frames
                if (Math.floor(player.invincibilityTimer / 10) % 2 === 0) {
                    drawPattern(ctx, playerPattern, px, py, GAME_PIXEL_MAGNIFICATION, playerColor);
                }
                player.invincibilityTimer--;
                if (player.invincibilityTimer <= 0) {
                    player.isInvincible = false;
                }
            } else {
                // Draw player normally (not exploding, not invincible)
                drawPattern(ctx, playerPattern, px, py, GAME_PIXEL_MAGNIFICATION, playerColor);
            }
        }

        // Draw player bullets
        function drawBullets() {
            bullets.forEach(bullet => {
                // Player bullets are white
                drawPattern(ctx, playerBulletSprite, bullet.x, bullet.y, GAME_PIXEL_MAGNIFICATION, '#fff');
            });
        }

        // Draw alien bombs (now animated bullets)
        function drawBombs() {
            bombs.forEach(bomb => {
                // Alien bullets are white
                drawPattern(ctx, alienBulletFrames[bomb.frameIndex], bomb.x, bomb.y, GAME_PIXEL_MAGNIFICATION, '#FFFFFF');
            });
        }

        // Helper function to get alien's current absolute position for drawing/collision
        function getAlienAbsPos(alien) {
            let alienWidth_ORIG = (alien.gridRow === 0) ? ALIEN_SPRITE_WIDTH_30_PTS_ORIG : ALIEN_SPRITE_WIDTH_10_20_PTS_ORIG;
            
            let localOffset = 0;
            // Ensure alien.gridRow is a valid index for wavePhases
            const rowDelay = wavePhases[alien.gridRow] !== undefined ? wavePhases[alien.gridRow] : 0;

            // Only apply local offset if the tickCounter has passed the row's delay
            // And if the alien is alive and not exploding (so it's part of the moving formation)
            // Also, ensure tickCounter is within the valid range for the current movement interval
            if (alien.alive && !alien.isExploding) { // Removed tickCounter condition here as it's for movement, not drawing
                let effectiveStep_ORIG = alienStep_ORIG;
                if (aliensAliveCount === 1) {
                    if (alienDirection === 1) {
                        effectiveStep_ORIG = 3;
                    } else {
                        effectiveStep_ORIG = 2;
                    }
                }
                // This localOffset is the *current step* being visually applied
                // This logic is for drawing the alien's movement, not the explosion itself
                // The explosion should be drawn at the alien's *current* position, not its next step.
                // Re-evaluating this: the alien's x,y will be updated by moveAliens, so getAlienAbsPos
                // should reflect its current position for drawing.
                // The localOffset is part of the calculation of the current position based on formationBaseX.
                // So, if the alien is exploding, it should *not* have this localOffset applied for its drawing,
                // as it's static during explosion.
            }

            // Calculate position relative to the formation's base, plus the local offset
            // When exploding, the alien's position should be fixed at the point of explosion.
            // So, for an exploding alien, we should not apply the `localOffset` as it's not moving.
            // The alien's `x` and `y` properties should ideally be its last known position before explosion.
            // For now, let's keep the `getAlienAbsPos` as is, and ensure `moveAliens` doesn't move exploding aliens.
            const x = formationBaseX + alien.gridCol * (alienWidth_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX + ALIEN_HORIZONTAL_GAP_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX);
            const y = formationBaseY + alien.gridRow * (ALIEN_SPRITE_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY + ALIEN_VERTICAL_GAP_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY);
            return { x, y };
        }

        // Draw aliens (classic pixel art from image)
        function drawAliens() {
            aliens.forEach(alien => {
                if (alien.alive) {
                    ctx.globalAlpha = 1.0; // Ensure full opacity for white invaders
                    ctx.fillStyle = '#fff'; // WHITE for classic look

                    const alienPos = getAlienAbsPos(alien); // Get calculated position
                    const ax = alienPos.x;
                    const ay = alienPos.y;
                    const aw = alien.width * scaleX; // Apply scaleX here
                    const ah = alien.height * scaleY; // Apply scaleY here

                    if (alien.isExploding) {
                        ctx.fillStyle = '#fff'; // Explosion is white
                        const currentPixelMap = ALIEN_EXPLOSION_PATTERN; // Use the new 8x8 pattern

                        // Calculate offset to center the 8x8 explosion within the alien's scaled bounding box
                        const explosionOriginalWidth = ALIEN_EXPLOSION_PATTERN[0].length; // 8
                        const explosionOriginalHeight = ALIEN_EXPLOSION_PATTERN.length; // 8

                        // Calculate the rendered width/height of the explosion pattern (scaled by GAME_PIXEL_MAGNIFICATION and current scale)
                        const renderedExplosionWidth = explosionOriginalWidth * GAME_PIXEL_MAGNIFICATION * scaleX;
                        const renderedExplosionHeight = explosionOriginalHeight * GAME_PIXEL_MAGNIFICATION * scaleY;

                        // Calculate the offset to center the explosion within the alien's *scaled* dimensions
                        const offsetX_explosion = (aw - renderedExplosionWidth) / 2;
                        const offsetY_explosion = (ah - renderedExplosionHeight) / 2;

                        // Draw using the generic drawPattern function
                        drawPattern(ctx, currentPixelMap, ax + offsetX_explosion, ay + offsetY_explosion, GAME_PIXEL_MAGNIFICATION, '#fff');

                    } else {
                        // Use the appropriate pixel map based on the current animation frame
                        const currentPixelMap = alienAnimationFrame === 0 ? alien.pixelMap_frame1 : alien.pixelMap_frame2;
                        const pixelSizeX = aw / currentPixelMap[0].length;
                        const pixelSizeY = ah / currentPixelMap.length;

                        for (let row = 0; row < currentPixelMap.length; row++) {
                            for (let col = 0; col < currentPixelMap[row].length; col++) {
                                if (currentPixelMap[row][col] === 1) {
                                    ctx.fillRect(ax + col * pixelSizeX, ay + row * pixelSizeY, pixelSizeX, pixelSizeY);
                                }
                            }
                        }
                    }
                    // Ensure globalAlpha is reset after drawing aliens if other elements use it
                    ctx.globalAlpha = 1.0; 
                }
            });
        }

        // Draw barriers (with visual damage)
        function drawBarriers() {
            barriers.forEach(barrier => {
                // Only draw if the barrier still has active pixels
                const hasActivePixels = barrier.pixelMap.some(row => row.some(pixel => pixel === 1));
                if (hasActivePixels) {
                    const bx = barrier.x;
                    const by = barrier.y;
                    const bw = barrier.width; // Already scaled
                    const bh = barrier.height; // Already scaled

                    const pixelSizeX = bw / BARRIER_PIXEL_WIDTH_ORIG;
                    const pixelSizeY = bh / BARRIER_PIXEL_HEIGHT_ORIG;

                    ctx.fillStyle = '#0f0'; // GREEN for classic look
                    for (let row = 0; row < BARRIER_PIXEL_HEIGHT_ORIG; row++) {
                        for (let col = 0; col < BARRIER_PIXEL_WIDTH_ORIG; col++) {
                            if (barrier.pixelMap[row][col] === 1) {
                                ctx.fillRect(bx + col * pixelSizeX, by + row * pixelSizeY, pixelSizeX, pixelSizeY);
                            }
                        }
                    }
                }
            });
        }

        // Draw UFO (red, pixelated)
        function drawUFO() {
            if (ufo.alive) {
                const ux = ufo.x;
                const uy = ufo.y;
                const uw = ufo.width * scaleX; // Apply scaleX here
                const uh = ufo.height * scaleY; // Apply scaleY here

                if (ufo.exploding) {
                    ctx.fillStyle = '#fff'; // Explosion is white
                    const currentExplosionStateIndex = Math.floor(ufo.explosionTick / UFO_EXPLOSION_STATE_DURATION);
                    let patternToDraw;

                    if (currentExplosionStateIndex < ufoExplosionFrames.length) {
                        patternToDraw = ufoExplosionFrames[currentExplosionStateIndex];
                    } else {
                        patternToDraw = blankPattern; // Should not be reached if logic is correct, but as a fallback
                    }

                    // Calculate offset to center the 8x8 explosion within the UFO's scaled bounding box
                    const explosionOriginalWidth = patternToDraw[0].length; // 8
                    const explosionOriginalHeight = patternToDraw.length; // 8

                    const renderedExplosionWidth = explosionOriginalWidth * GAME_PIXEL_MAGNIFICATION * scaleX;
                    const renderedExplosionHeight = explosionOriginalHeight * GAME_PIXEL_MAGNIFICATION * scaleY;

                    const offsetX_explosion = (uw - renderedExplosionWidth) / 2;
                    const offsetY_explosion = (uh - renderedExplosionHeight) / 2;

                    drawPattern(ctx, patternToDraw, ux + offsetX_explosion, uy + offsetY_explosion, GAME_PIXEL_MAGNIFICATION, '#fff');

                } else {
                    ctx.fillStyle = '#f00'; // Red UFO - kept as red as per image
                    const pixelSizeX = uw / ufoPixelMap[0].length; 
                    const pixelSizeY = uh / ufoPixelMap.length;  

                    for (let row = 0; row < ufoPixelMap.length; row++) {
                        for (let col = 0; col < ufoPixelMap[row].length; col++) {
                            if (ufoPixelMap[row][col] === 1) {
                                ctx.fillRect(ux + col * pixelSizeX, uy + row * pixelSizeY, pixelSizeX, pixelSizeY);
                            }
                        }
                    }
                }
            }
        }

        // Draw score and lives (SCORE<1> 0000 format)
        function drawScore() {
            ctx.fillStyle = '#fff';
            ctx.font = `${20 * scaleY}px 'Press Start 2P'`; // Font size based on scale
            ctx.textAlign = 'left';

            // SCORE<1>
            // Original Y = 8-16px, so 10px original is a good center for text
            ctx.fillText(`SCORE<1>`, 20 * scaleX, 10 * GAME_PIXEL_MAGNIFICATION * scaleY); 
            ctx.fillText(`${String(score).padStart(4, '0')}`, 20 * scaleX, 25 * GAME_PIXEL_MAGNIFICATION * scaleY); 

            // HI-SCORE
            ctx.textAlign = 'center';
            ctx.fillText(`HI-SCORE`, canvas.width / 2, 10 * GAME_PIXEL_MAGNIFICATION * scaleY);
            ctx.fillText(`${String(highScore).padStart(4, '0')}`, canvas.width / 2, 25 * GAME_PIXEL_MAGNIFICATION * scaleY);

            // SCORE<2> (Placeholder for 2-player score)
            ctx.textAlign = 'right';
            ctx.fillText(`SCORE<2>`, canvas.width - 20 * scaleX, 10 * GAME_PIXEL_MAGNIFICATION * scaleY); 
            ctx.fillText(`0000`, canvas.width - 20 * scaleX, 25 * GAME_PIXEL_MAGNIFICATION * scaleY); 

            // Bottom line for lives and credit
            ctx.fillStyle = '#0f0'; // Green line
            ctx.fillRect(0, canvas.height - 40 * scaleY, canvas.width, 2 * scaleY); // Adjusted Y position of the line

            // Lives at bottom left (numerical display positioned below green line)
            ctx.textAlign = 'left';
            ctx.fillText(`${player.lives}`, 20 * scaleX, canvas.height - 15 * scaleY); // Adjusted Y to be below the line

            // Draw lives as player ship icons at bottom left
            const lifeIconWidth = player.width; // Use player's actual width (already scaled)
            const lifeIconHeight = player.height; // Use player's actual height (already scaled)
            const lifeStartX = 40 * scaleX; // Start position for icons (adjusted)
            const lifeY = canvas.height - 35 * scaleY; // Y position for life icons (aligned with green line)

            // Player Pixel Map (re-used for life icons)
            const lifePlayerPixelMap = playerPattern; // Use the same pattern as the player

            for (let i = 0; i < player.lives; i++) {
                const lx = lifeStartX + (lifeIconWidth + 5 * GAME_PIXEL_MAGNIFICATION * scaleX) * i; // Spacing between icons
                const ly = lifeY;

                ctx.fillStyle = playerColor; // Green for life icons
                const iconPixelSizeX = lifeIconWidth / lifePlayerPixelMap[0].length;
                const iconPixelSizeY = lifeIconHeight / lifePlayerPixelMap.length;

                for (let row = 0; row < lifePlayerPixelMap.length; row++) {
                    for (let col = 0; col < lifePlayerPixelMap[row].length; col++) {
                        if (lifePlayerPixelMap[row][col] === 1) {
                            ctx.fillRect(lx + col * iconPixelSizeX, ly + row * iconPixelSizeY, iconPixelSizeX, iconPixelSizeY);
                        }
                    }
                }
            }

            // CREDIT 00 at bottom right
            ctx.textAlign = 'right';
            ctx.fillText(`CREDIT 00`, canvas.width - 20 * scaleX, canvas.height - 15 * scaleY); // Adjusted Y to align with lives number

            // Pause message
            if (gamePaused) {
                ctx.fillStyle = '#00ff00';
                ctx.font = `${30 * scaleY}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
            }
        }

        // Move player
        function movePlayer() {
            // Player does not move if exploding
            if (player.isExploding) return;

            player.x += player.dx * scaleX;
            if (player.x < 0) player.x = 0;
            if (player.x + (player.width) > canvas.width) player.x = canvas.width - (player.width);
        }

        // Move player bullets
        function moveBullets() {
            bullets.forEach((bullet, index) => {
                bullet.y -= bulletSpeed * scaleY;
                if (bullet.y < 0) {
                    bullets.splice(index, 1);
                    bulletOnScreen = false; // Bullet left screen
                }
            });
        }

        // Move alien bombs (now animated alien bullets)
        function moveBombs() {
            bombs.forEach((bomb, index) => {
                bomb.tick++;
                if (bomb.tick % ALIEN_BULLET_ANIMATION_SPEED === 0) {
                    bomb.frameIndex = (bomb.frameIndex + 1) % alienBulletFrames.length;
                }
                bomb.y += bombSpeed * scaleY;
                if (bomb.y > canvas.height) {
                    bombs.splice(index, 1);
                }
            });
        }

        // Drop bombs from aliens
        function dropBombs() {
            // Only aliens in the bottom-most row of their column can shoot
            const bottomAliens = new Map(); // Map column index to bottom-most alien

            aliens.forEach(alien => {
                if (alien.alive && !alien.isExploding) { // Only alive, non-exploding aliens can shoot
                    const alienPos = getAlienAbsPos(alien); // Get calculated position
                    const col = alien.gridCol; 
                    if (!bottomAliens.has(col) || alienPos.y > getAlienAbsPos(bottomAliens.get(col)).y) {
                        bottomAliens.set(col, alien);
                    }
                }
            });

            bottomAliens.forEach(alien => {
                if (Math.random() < bombDropChance) {
                    const alienPos = getAlienAbsPos(alien); // Get calculated position
                    bombs.push({
                        x: alienPos.x + (alien.width * scaleX) / 2 - (ALIEN_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) / 2, // Center alien bullet
                        y: alienPos.y + (alien.height * scaleY),
                        width: ALIEN_BULLET_WIDTH_ORIG, // Store original width for pattern drawing
                        height: ALIEN_BULLET_HEIGHT_ORIG, // Store original height for pattern drawing
                        frameIndex: 0, // Start at first animation frame
                        tick: 0 // Initialize tick counter for animation
                    });
                    try {
                        bombSynth.triggerAttackRelease('C3', '8n'); // Play a bomb sound
                    } catch (e) {
                        console.log('Bomb sound playback failed:', e);
                    }
                }
            });
        }

        // Move aliens (synchronized block movement with wave effect)
        function moveAliens() {
            alienMoveTimer--;

            if (alienMoveTimer <= 0) {
                // Reset timer for the next full formation move
                currentAlienMoveInterval = initialAlienMoveInterval - 
                                           (initialAlienMoveInterval - minAlienMoveInterval) * (1 - (aliensAliveCount / totalAliens));
                
                if (currentAlienMoveInterval < minAlienMoveInterval) {
                    currentAlienMoveInterval = minAlienMoveInterval;
                }
                alienMoveTimer = currentAlienMoveInterval;

                // Reset tickCounter for the new movement cycle
                tickCounter++; // Increment tickCounter here for alien movement
                if (tickCounter >= currentAlienMoveInterval) {
                    tickCounter = 0; // Reset after a full interval
                }

                // Play invader movement sound in sync with the step
                try {
                    const noteDuration = (currentAlienMoveInterval / 60) * 0.8; 
                    invaderMoveSynth.triggerAttackRelease(invaderMoveNotes[currentNoteIndex], noteDuration); 
                    currentNoteIndex = (currentNoteIndex + 1) % invaderMoveNotes.length; 
                } catch (e) {
                    console.log('Invader movement sound playback failed:', e);
                }

                // Determine the step size for this full formation move
                let effectiveStep_ORIG = alienStep_ORIG; // Default to 2 original pixels
                if (aliensAliveCount === 1) {
                    if (alienDirection === 1) {
                        effectiveStep_ORIG = 3;
                    } else {
                        effectiveStep_ORIG = 2;
                    }
                }
                
                // Update the formation's base X position
                formationBaseX += effectiveStep_ORIG * GAME_PIXEL_MAGNIFICATION * alienDirection * scaleX;

                // Find the current leftmost and rightmost X positions of the *live* formation
                let leftmostAlienX = Infinity;
                let rightmostAlienX = -Infinity;
                let currentLowestAlienY = 0;

                aliens.forEach(alien => {
                    if (alien.alive && !alien.isExploding) {
                        // For edge detection, use the base position + its grid offset (without localOffset for this check)
                        let alienWidth_ORIG = (alien.gridRow === 0) ? ALIEN_SPRITE_WIDTH_30_PTS_ORIG : ALIEN_SPRITE_WIDTH_10_20_PTS_ORIG;
                        const currentAlienX = formationBaseX + alien.gridCol * (alienWidth_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX + ALIEN_HORIZONTAL_GAP_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX);
                        const currentAlienY = formationBaseY + alien.gridRow * (ALIEN_SPRITE_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY + ALIEN_VERTICAL_GAP_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY);

                        if (currentAlienX < leftmostAlienX) leftmostAlienX = currentAlienX;
                        if (currentAlienX + (alien.width * scaleX) > rightmostAlienX) rightmostAlienX = currentAlienX + (alien.width * scaleX);
                        if (currentAlienY + (alien.height * scaleY) > currentLowestAlienY) currentLowestAlienY = currentAlienY + (alien.height * scaleY);
                    }
                });

                let shouldMoveDown = false;

                // Check if the entire formation hits the canvas edge
                if (rightmostAlienX >= canvas.width && alienDirection === 1) {
                    alienDirection *= -1; // Reverse horizontal direction
                    shouldMoveDown = true; // Flag to move down
                } else if (leftmostAlienX <= 0 && alienDirection === -1) {
                    alienDirection *= -1; // Reverse horizontal direction
                    shouldMoveDown = true; // Flag to move down
                }

                // If should move down, update formation's base Y position
                if (shouldMoveDown) {
                    formationBaseY += ALIEN_VERTICAL_DROP_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY; // Move down by full row step
                }

                // Toggle animation frame for the entire formation (after a full cycle)
                alienAnimationFrame = 1 - alienAnimationFrame; 

                // Check if aliens reached player's level (after potential downward move)
                if (aliensAliveCount > 0 && currentLowestAlienY > player.y) {
                    handlePlayerHit(); // Trigger player hit logic
                }
            }
        }

        // Move UFO
        function moveUFO() {
            if (ufo.exploding) {
                ufo.explosionTick++;
                if (ufo.explosionTick >= UFO_EXPLOSION_TOTAL_DURATION) {
                    ufo.exploding = false;
                    ufo.alive = false; // Remove UFO after explosion animation
                }
                return; // Do not move UFO if it's exploding
            }

            if (ufo.alive) {
                ufo.x += ufo.speed * ufo.direction * scaleX; // Apply ufo.direction here
                // If UFO goes off screen, make it inactive
                if (ufo.direction === 1 && ufo.x > canvas.width) {
                    ufo.alive = false;
                    try {
                        // Use ufoPlayer if available, otherwise ufoSynth
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } catch (e) {
                        console.log('UFO sound stop failed:', e);
                    }
                } else if (ufo.direction === -1 && ufo.x + (ufo.width * scaleX) < 0) {
                    ufo.alive = false;
                    try {
                        // Use ufoPlayer if available, otherwise ufoSynth
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } catch (e) {
                        console.log('UFO sound stop failed:', e);
                    }
                }
            } else {
                // Spawn UFO periodically
                ufoSpawnTimer--;
                if (ufoSpawnTimer <= 0) {
                    ufo.alive = true;
                    ufo.direction = Math.random() < 0.5 ? 1 : -1; // Random direction
                    ufo.x = ufo.direction === 1 ? -(ufo.width * scaleX) : canvas.width; // Start off-screen
                    ufoSpawnTimer = ufoSpawnInterval + Math.random() * ufoSpawnInterval; // Next spawn interval
                    try {
                        // Use ufoPlayer if available, otherwise ufoSynth
                        if (ufoPlayer) { ufoPlayer.start(); }
                        else if (ufoSynth) { ufoSynth.start(); }
                    } catch (e) {
                        console.log('UFO sound start failed:', e);
                    }
                }
            }
        }

        // Handle player hit logic
        function handlePlayerHit() {
            if (player.isExploding || player.isInvincible) return; // Cannot be hit if already exploding or invincible

            player.lives--;
            player.isExploding = true;
            player.explosionFrameCounter = 0; // Start explosion animation from beginning

            // Play specific player explosion sound if available, otherwise fallback
            try {
                if (playerExplosionPlayer) { playerExplosionPlayer.start(); }
                else { explodeSynth.triggerAttackRelease('8n'); } // Fallback
            } catch (e) {
                console.log('Player explosion sound playback failed:', e);
                explodeSynth.triggerAttackRelease('8n'); // Ensure fallback plays on error
            }

            bombs.length = 0; // Clear all bombs on player hit

            if (player.lives <= 0) {
                playerDeathTimer = 90; // Game over pause
            }
            // Respawn logic (including invincibility) is now handled in drawPlayer after explosion completes
        }


        // Check collisions
        function checkCollisions() {
            // Array to hold bullets marked for removal
            const bulletsToRemove = [];

            // Player bullets vs Aliens
            bullets.forEach((bullet, bulletIndex) => {
                aliens.forEach((alien, alienIndex) => {
                    if (alien.alive && !alien.isExploding) { 
                        const alienPos = getAlienAbsPos(alien); // Get calculated position
                        if (bullet.x < alienPos.x + (alien.width * scaleX) &&
                            bullet.x + (PLAYER_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) > alienPos.x && // Use original bullet width
                            bullet.y < alienPos.y + (alien.height * scaleY) &&
                            bullet.y + (PLAYER_BULLET_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY) > alienPos.y) { // Use original bullet height
                            
                            alien.health--;
                            bulletsToRemove.push(bulletIndex); // Mark bullet for removal
                            bulletOnScreen = false; 
                            
                            if (alien.health <= 0) {
                                alien.isExploding = true; 
                                alien.explosionTimer = ALIEN_EXPLOSION_DURATION; // Use the new duration
                                aliensAliveCount--; 
                                score += alien.points; 
                                try {
                                    if (invaderKilledPlayer) { invaderKilledPlayer.start(); }
                                    else if (synthesizedInvaderKilledSynth) { synthesizedInvaderKilledSynth.triggerAttackRelease('8n'); }
                                } catch (e) {
                                    console.log('Invader killed sound playback failed:', e);
                                }
                            }
                        }
                    }
                });

                // Player bullets vs Barriers
                barriers.forEach((barrier) => {
                    // Calculate hit pixel in barrier's local coordinates (32x32 grid)
                    const pixelSizeX = barrier.width / BARRIER_PIXEL_WIDTH_ORIG;
                    const pixelSizeY = barrier.height / BARRIER_PIXEL_HEIGHT_ORIG;

                    // Calculate bullet's center relative to the barrier's top-left corner
                    let hitX_abs = (bullet.x + (PLAYER_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) / 2); 
                    let hitY_abs = (bullet.y + (PLAYER_BULLET_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY) / 2); 

                    // Convert to barrier's local 32x32 pixel map indices
                    let hitCol_32x32 = Math.floor((hitX_abs - barrier.x) / pixelSizeX);
                    let hitRow_32x32 = Math.floor((hitY_abs - barrier.y) / pixelSizeY);

                    // Check if the bullet is within the barrier's 32x32 bounding box
                    if (hitCol_32x32 >= 0 && hitCol_32x32 < BARRIER_PIXEL_WIDTH_ORIG &&
                        hitRow_32x32 >= 0 && hitRow_32x32 < BARRIER_PIXEL_HEIGHT_ORIG) {
                        
                        // Check if the specific pixel at the hit location is solid (1)
                        if (barrier.pixelMap[hitRow_32x32][hitCol_32x32] === 1) {
                            // Damage the pixel
                            barrier.pixelMap[hitRow_32x32][hitCol_32x32] = 0; 
                            bulletsToRemove.push(bulletIndex); // Mark bullet for removal
                            bulletOnScreen = false; // Bullet removed, can shoot again
                            return; // Stop checking this bullet against other barriers
                        }
                    }
                });

                // Player bullets vs UFO
                if (ufo.alive && !ufo.exploding && // Only hit if UFO is alive and not already exploding
                    bullet.x < ufo.x + ufo.width * scaleX &&
                    bullet.x + (PLAYER_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) > ufo.x &&
                    bullet.y < ufo.y + ufo.height * scaleY &&
                    bullet.y + (PLAYER_BULLET_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY) > ufo.y) {
                    
                    bulletsToRemove.push(bulletIndex); // Mark bullet for removal
                    bulletOnScreen = false; // Bullet removed, can shoot again
                    
                    ufo.exploding = true; // Set UFO to exploding state
                    ufo.explosionTick = 0; // Reset explosion tick
                    score += ufo.points; // Add UFO points
                    try {
                        playUfoExplosionSound(); // Play UFO explosion sound
                        // Stop UFO continuous sound
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } catch (e) {
                        console.log('UFO sound stop failed:', e);
                    }
                }
            }); 

            // Filter out bullets marked for removal
            bulletsToRemove.sort((a, b) => b - a).forEach(index => {
                bullets.splice(index, 1);
            });


            // Array to hold bombs marked for removal
            const bombsToRemove = [];

            // Alien bombs vs Player
            bombs.forEach((bomb, bombIndex) => {
                if (!player.isExploding && !player.isInvincible && // Only hit if not exploding or invincible
                    bomb.x < player.x + (player.width) && // Use player.width (already scaled)
                    bomb.x + (ALIEN_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) > player.x &&
                    bomb.y < player.y + (player.height) && // Use player.height (already scaled)
                    bomb.y + (ALIEN_BULLET_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY) > player.y) {
                    
                    bombsToRemove.push(bombIndex); // Mark bomb for removal
                    handlePlayerHit(); // Call the new handler
                    return; 
                }

                // Alien bombs vs Barriers
                barriers.forEach((barrier) => {
                    // Calculate hit pixel in barrier's local coordinates (32x32 grid)
                    const pixelSizeX = barrier.width / BARRIER_PIXEL_WIDTH_ORIG;
                    const pixelSizeY = barrier.height / BARRIER_PIXEL_HEIGHT_ORIG;

                    // Calculate bomb's center relative to the barrier's top-left corner
                    let hitX_abs = (bomb.x + (ALIEN_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) / 2); 
                    let hitY_abs = (bomb.y + (ALIEN_BULLET_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY) / 2); 

                    // Convert to barrier's local 32x32 pixel map indices
                    let hitCol_32x32 = Math.floor((hitX_abs - barrier.x) / pixelSizeX);
                    let hitRow_32x32 = Math.floor((hitY_abs - barrier.y) / pixelSizeY);

                    // Check if the bomb is within the barrier's 32x32 bounding box
                    if (hitCol_32x32 >= 0 && hitCol_32x32 < BARRIER_PIXEL_WIDTH_ORIG &&
                        hitRow_32x32 >= 0 && hitRow_32x32 < BARRIER_PIXEL_HEIGHT_ORIG) {
                        
                        // Check if the specific pixel at the hit location is solid (1)
                        if (barrier.pixelMap[hitRow_32x32][hitCol_32x32] === 1) {
                            // Damage the pixel
                            barrier.pixelMap[hitRow_32x32][hitCol_32x32] = 0; 
                            bombsToRemove.push(bombIndex); // Mark bomb for removal
                            return; // Stop checking this bomb against other barriers
                        }
                    }
                });
            });

            // Filter out bombs marked for removal
            bombsToRemove.sort((a, b) => b - a).forEach(index => {
                bombs.splice(index, 1);
            });
        }

        // Update game
        function update() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStars(); // Draw stars first for background

            if (!gameStarted) {
                drawStartScreen();
                animationFrameId = requestAnimationFrame(update);
                return;
            }

            if (gameOver) {
                ctx.fillStyle = '#00ff00';
                ctx.font = `${40 * scaleY}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                ctx.fillText(`SCORE: ${score}`, canvas.width / 2, canvas.height / 2 + 48 * scaleY);
                ctx.fillText('Press Enter to Reset', canvas.width / 2, canvas.height / 2 + 96 * scaleY);
                ctx.textAlign = 'left';
                cancelAnimationFrame(animationFrameId); // Stop the game loop
                return;
            }

            // Handle pause logic
            if (gamePaused) {
                drawPlayer();
                drawBullets();
                drawBombs();
                drawAliens();
                drawBarriers();
                drawUFO();
                drawScore(); // Draw score and "PAUSED" message
                animationFrameId = requestAnimationFrame(update); // Keep requesting frames to show PAUSED message
                return; // Skip all game logic if paused
            }

            // Handle player death pause (after explosion animation and if lives are zero)
            if (playerDeathTimer > 0) {
                playerDeathTimer--;
                if (playerDeathTimer === 0) {
                    gameOver = true; // Transition to game over after pause
                }
                // Only draw, do not move or check collisions during this pause
                drawPlayer(); // Still draw the player (or blank if exploding finished)
                drawBullets();
                drawBombs();
                drawAliens();
                drawBarriers();
                drawUFO();
                drawScore();
                animationFrameId = requestAnimationFrame(update);
                return; // Skip normal game logic
            }

            // Update explosion timers for aliens
            aliens.forEach(alien => {
                if (alien.isExploding) {
                    alien.explosionTimer--;
                    if (alien.explosionTimer <= 0) {
                        // Alien disappears after explosion, but aliensAliveCount is already decremented
                        alien.alive = false; 
                    }
                }
            });

            // Increment tickCounter for wave effect
            // Moved to inside moveAliens for precise control over wave effect timing
            // tickCounter++; 

            if (aliensAliveCount === 0) {
                // Win condition - start next wave
                score += 100; // Bonus for clearing wave
                // When starting a new wave, reset alien movement interval to initial
                currentAlienMoveInterval = initialAlienMoveInterval; 
                alienMoveTimer = 0; // Reset timer
                currentNoteIndex = 0; // Reset note index for sound loop
                initAliens(); // Start a new wave of aliens (resets individual alien positions)
                initBarriers(); // Re-initialize barriers for new wave
                bullets.length = 0;
                bombs.length = 0;
                bulletOnScreen = false; // Reset bullet state
                ufo.alive = false; // Ensure UFO is gone
                ufo.exploding = false; // Reset UFO explosion state
                ufo.explosionTick = 0; // Reset UFO explosion tick
                ufoSpawnTimer = ufoSpawnInterval; // Reset UFO timer for new wave
            }

            // Update high score
            if (score > highScore) {
                highScore = score;
            }

            // Player invincibility timer (moved from player.isHit)
            if (player.isInvincible) {
                player.invincibilityTimer--;
                if (player.invincibilityTimer <= 0) {
                    player.isInvincible = false;
                }
            }

            movePlayer();
            moveBullets();
            moveBombs();
            dropBombs();
            moveAliens(); // This function now handles timing internally
            moveUFO(); // Move UFO
            checkCollisions();
            drawPlayer();
            drawBullets();
            drawBombs();
            drawAliens();
            drawBarriers();
            drawUFO(); // Draw UFO
            drawScore();

            animationFrameId = requestAnimationFrame(update);
        }

        // Controls
        document.addEventListener('keydown', e => {
            e.preventDefault(); // Prevent browser default behavior for arrow keys and space
            if (e.key === 'Enter') {
                resetGame(); // Reset game immediately on Enter
                return;
            }

            // Only allow pause/unpause if game has started and not game over or in death pause
            if (e.key === 'p' || e.key === 'P') { // 'P' key for pause/resume
                if (gameStarted && !gameOver && playerDeathTimer <= 0) {
                    gamePaused = !gamePaused;
                    if (gamePaused) {
                        // Stop UFO sound if paused
                        if (ufoPlayer && ufoPlayer.state === 'started') { ufoPlayer.stop(); }
                        else if (ufoSynth && ufoSynth.state === 'started') { ufoSynth.stop(); }
                    } else {
                        // Resume UFO sound if unpaused and UFO is alive
                        if (ufo.alive) {
                            if (ufoPlayer) { ufoPlayer.start(); }
                            else if (ufoSynth) { ufoSynth.start(); }
                        }
                    }
                }
                return; // Consume 'p' event
            }

            if (!gameStarted || gameOver || player.isExploding || playerDeathTimer > 0 || gamePaused) {
                // If game not started, over, exploding, in death pause, or paused, ignore other controls
                return;
            }

            if (e.key === 'ArrowLeft') player.dx = -player.speed;
            if (e.key === 'ArrowRight') player.dx = player.speed;
            if (e.key === ' ' && canShoot && !bulletOnScreen) { // Spacebar for shooting
                bullets.push({
                    x: player.x + (player.width) / 2 - (PLAYER_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) / 2, // Center player bullet
                    y: player.y - (PLAYER_BULLET_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY), // Position above player
                    width: PLAYER_BULLET_WIDTH_ORIG, // Store original width for pattern drawing
                    height: PLAYER_BULLET_HEIGHT_ORIG // Store original height for pattern drawing
                });
                try {
                    // Play shoot sound using Tone.Player if available, else synthesized
                    if (shootPlayer) { shootPlayer.start(); }
                    else if (synthesizedShootSynth) { synthesizedShootSynth.triggerAttackRelease('C4', '16n'); }
                } catch (e) {
                    console.log('Shoot sound playback failed:', e);
                }
                canShoot = false;
                bulletOnScreen = true; // Set bullet on screen flag
                setTimeout(() => {
                    canShoot = true;
                }, shootCooldown);
            }
        });

        document.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') player.dx = 0;
        });

        // Mobile Touch Controls
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted || gameOver || player.isExploding || playerDeathTimer > 0 || gamePaused) return;
            player.dx = -player.speed;
        });
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.dx = 0;
        });

        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted || gameOver || player.isExploding || playerDeathTimer > 0 || gamePaused) return;
            player.dx = player.speed;
        });
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            player.dx = 0;
        });

        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!gameStarted || gameOver || !canShoot || bulletOnScreen || player.isExploding || playerDeathTimer > 0 || gamePaused) return;
            bullets.push({
                x: player.x + (player.width) / 2 - (PLAYER_BULLET_WIDTH_ORIG * GAME_PIXEL_MAGNIFICATION * scaleX) / 2, // Center player bullet
                y: player.y - (PLAYER_BULLET_HEIGHT_ORIG * GAME_PIXEL_MAGNIFICATION * scaleY), // Position above player
                width: PLAYER_BULLET_WIDTH_ORIG, // Store original width for pattern drawing
                height: PLAYER_BULLET_HEIGHT_ORIG // Store original height for pattern drawing
            });
            try {
                // Play shoot sound using Tone.Player if available, else synthesized
                if (shootPlayer) { shootPlayer.start(); }
                else if (synthesizedShootSynth) { synthesizedShootSynth.triggerAttackRelease('C4', '16n'); }
            } catch (e) {
                console.log('Shoot sound playback failed:', e);
            }
            canShoot = false;
            bulletOnScreen = true; // Set bullet on screen flag
            setTimeout(() => {
                canShoot = true;
            }, shootCooldown);
        });

        // Initialize and start the game
        window.onload = () => {
            resizeCanvas(); // Set initial canvas size and scale factors
            setupAudio(); // Initialize Tone.js synths
            update(); // Start the game loop (will display start screen)
        };

        window.addEventListener('resize', () => {
            resizeCanvas();
            // If game is active, resume animation
            if (gameStarted && !gameOver) {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                update();
            } else if (!gameStarted || gameOver) {
                // If on start/game over screen, just redraw it
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!gameStarted) drawStartScreen();
                else if (gameOver) {
                    ctx.fillStyle = '#00ff00';
                    ctx.font = `${40 * scaleY}px 'Press Start 2P'`;
                    ctx.textAlign = 'center';
                    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2);
                    ctx.fillText(`SCORE: ${score}`, canvas.width / 2, canvas.height / 2 + 48 * scaleY);
                    ctx.fillText('Press Enter to Reset', canvas.width / 2, canvas.height / 2 + 96 * scaleY);
                    ctx.textAlign = 'left';
                }
            }
        });

    </script>
</body>
</html>

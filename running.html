<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running Track Game - Dad's Winter Sport Competition</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #gameCanvas { display: block; margin: 0 auto; max-width: 100%; height: auto; }
        a { position: absolute; top: 10px; left: 10px; color: white; background: blue; padding: 10px; text-decoration: none; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <a href="https://zapback100.github.io/Dads-Games/index.html">Back to Main Menu</a>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Reference Notes
        const radiusSemicircle = 36.5; // in meters
        const straightLength = 84.39;  // in meters
        const laneWidth = 1.22;        // in meters
        const nLanes = 8;

        const trackWidth = laneWidth * nLanes;

        const runnerProportions = {
          torso: 0.5,
          upperLeg: 0.5,
          lowerLeg: 0.5,
          upperArm: 0.35,
          lowerArm: 0.35,
          headRadius: 0.2
        };

        const strideFrequency = 3.5; // Hz
        const stancePhase = 0.4;
        const swingPhase = 0.6;

        // Game Settings
        const raceDistances = [100, 200, 400];
        let currentRaceDistance = 400; // Default
        const maxPlayers = 2;
        const totalRunners = nLanes;

        // Game State
        let runners = [];
        let raceStarted = false;
        let raceFinished = false;
        let debugMode = false;
        let lastTimestamp = 0;

        // Scale for screen display (px per meter)
        const scale = 4.0; // Adjusted for canvas size (width ~177m *4 =708px, height ~93m *4 =372px)

        // Camera offset to center the track
        const maxR = radiusSemicircle + trackWidth;
        const trackBoundingWidth = straightLength + 2 * maxR;
        const trackBoundingHeight = 2 * maxR;
        const cameraOffsetX = (canvas.width - trackBoundingWidth * scale) / 2;
        const cameraOffsetY = (canvas.height - trackBoundingHeight * scale) / 2;

        // Runner Class
        class Runner {
          constructor(lane, isPlayer) {
            this.lane = lane;
            this.isPlayer = isPlayer;
            this.phase = Math.random();
            this.distanceTraveled = 0;
            this.speed = isPlayer ? 8 : 7 + Math.random() * 1.5; // m/s (adjust for 400m race pace)
            this.stagger = this.calculateStagger(currentRaceDistance);
            this.distanceTraveled = -this.stagger; // Start behind for outer lanes
            this.joints = { hip1: 0, knee1: 0, hip2: 0, knee2: 0, shoulder1: 0, elbow1: 0, shoulder2: 0, elbow2: 0 };
          }

          calculateStagger(distance) {
            const numCurves = distance === 100 ? 0 : distance === 200 ? 1 : 2;
            return numCurves * Math.PI * laneWidth * this.lane; // Extra distance per curve for lane (lane 0 = 0 stagger)
          }

          update(dt) {
            this.phase = (this.phase + strideFrequency * dt) % 1;
            this.distanceTraveled += this.speed * dt;

            // Simple sine-based gait for joint angles (in degrees)
            const twoPi = 2 * Math.PI;
            const phase1 = this.phase;
            const phase2 = (this.phase + 0.5) % 1;

            this.joints.hip1 = 40 * Math.sin(twoPi * phase1);
            this.joints.knee1 = 60 * Math.max(0, Math.sin(twoPi * phase1 + Math.PI / 2));
            this.joints.hip2 = 40 * Math.sin(twoPi * phase2);
            this.joints.knee2 = 60 * Math.max(0, Math.sin(twoPi * phase2 + Math.PI / 2));
            this.joints.shoulder1 = -this.joints.hip1;
            this.joints.elbow1 = 30 * Math.sin(twoPi * phase1 + Math.PI);
            this.joints.shoulder2 = -this.joints.hip2;
            this.joints.elbow2 = 30 * Math.sin(twoPi * phase2 + Math.PI);

            // Check for finish
            if (this.distanceTraveled >= currentRaceDistance && !raceFinished) {
              raceFinished = true;
              alert(`Runner in lane ${this.lane + 1} wins!`);
            }
          }

          draw() {
            const { position, angle } = this.getPositionAndAngle(this.distanceTraveled);
            const scaledX = position.x * scale + cameraOffsetX;
            const scaledY = position.y * scale + cameraOffsetY;

            ctx.save();
            ctx.translate(scaledX, scaledY);
            ctx.rotate(angle);

            // Draw stickman (side view, scaled)
            const s = scale;
            const toRad = (deg) => deg * Math.PI / 180;

            // Hip at origin
            // Torso
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -runnerProportions.torso * s);
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Head
            ctx.beginPath();
            ctx.arc(0, -runnerProportions.torso * s - runnerProportions.headRadius * s / 2, runnerProportions.headRadius * s, 0, 2 * Math.PI);
            ctx.stroke();

            // Legs (one forward, one back)
            this.drawLimb(0, 0, this.joints.hip1, runnerProportions.upperLeg * s, this.joints.knee1, runnerProportions.lowerLeg * s);
            this.drawLimb(0, 0, this.joints.hip2, runnerProportions.upperLeg * s, this.joints.knee2, runnerProportions.lowerLeg * s);

            // Arms (from shoulder)
            const shoulderY = -runnerProportions.torso * s * 0.8; // Shoulder position
            this.drawLimb(0, shoulderY, this.joints.shoulder1, runnerProportions.upperArm * s, this.joints.elbow1, runnerProportions.lowerArm * s);
            this.drawLimb(0, shoulderY, this.joints.shoulder2, runnerProportions.upperArm * s, this.joints.elbow2, runnerProportions.lowerArm * s);

            ctx.restore();

            if (debugMode) {
              ctx.fillStyle = 'black';
              ctx.fillText(`Lane ${this.lane + 1}: Phase ${this.phase.toFixed(2)}, Dist ${this.distanceTraveled.toFixed(1)}m`, scaledX + 10, scaledY - 10);
            }
          }

          drawLimb(startX, startY, angle1, length1, angle2, length2) {
            const rad1 = toRad(angle1);
            const endX1 = startX + length1 * Math.sin(rad1);
            const endY1 = startY + length1 * Math.cos(rad1);
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX1, endY1);

            const rad2 = toRad(angle2);
            const endX2 = endX1 + length2 * Math.sin(rad1 + rad2);
            const endY2 = endY1 + length2 * Math.cos(rad1 + rad2);
            ctx.lineTo(endX2, endY2);
            ctx.stroke();
          }

          getPositionAndAngle(d) {
            const r = radiusSemicircle + this.lane * laneWidth;
            const leftCenterX = r;
            const rightCenterX = straightLength + r;
            const centerY = r;

            const cum1 = straightLength;
            const cum2 = cum1 + Math.PI * r;
            const cum3 = cum2 + straightLength;
            const cum4 = cum3 + Math.PI * r;

            let position = { x: 0, y: 0 };
            let tangentAngle = 0;

            if (d < cum1) {
              // Bottom straight
              position.x = leftCenterX + d;
              position.y = 0;
              tangentAngle = 0; // Right
            } else if (d < cum2) {
              // Right curve
              const fraction = (d - cum1) / (Math.PI * r);
              const theta = 3 * Math.PI / 2 + fraction * Math.PI;
              position.x = rightCenterX + r * Math.cos(theta);
              position.y = centerY + r * Math.sin(theta);
              tangentAngle = theta + Math.PI / 2; // Tangent for counter-clockwise
            } else if (d < cum3) {
              // Top straight
              const fraction = (d - cum2) / straightLength;
              position.x = rightCenterX - fraction * straightLength;
              position.y = 2 * r;
              tangentAngle = Math.PI; // Left
            } else {
              // Left curve
              const fraction = (d - cum3) / (Math.PI * r);
              const theta = Math.PI / 2 + fraction * Math.PI;
              position.x = leftCenterX + r * Math.cos(theta);
              position.y = centerY + r * Math.sin(theta);
              tangentAngle = theta + Math.PI / 2; // Tangent for counter-clockwise
            }

            return { position, angle: tangentAngle };
          }
        }

        // Race Manager
        function initializeRace(numPlayers = 1, distance = 400) {
          currentRaceDistance = distance;
          runners = [];
          for (let lane = 0; lane < totalRunners; lane++) {
            const isPlayer = lane < numPlayers;
            runners.push(new Runner(lane, isPlayer));
          }
          raceStarted = true;
          raceFinished = false;
        }

        // Draw Track Geometry
        function drawTrack() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = 'gray';
          ctx.lineWidth = 1;

          for (let k = 0; k <= nLanes; k++) {
            const r = radiusSemicircle + k * laneWidth;
            const leftCenterX = r * scale + cameraOffsetX;
            const rightCenterX = (straightLength + r) * scale + cameraOffsetX;
            const centerY = r * scale + cameraOffsetY;

            ctx.beginPath();
            ctx.moveTo(leftCenterX, cameraOffsetY); // Adjusted for offset
            ctx.lineTo(rightCenterX, cameraOffsetY);
            ctx.arc(rightCenterX, centerY, r * scale, 3 * Math.PI / 2, Math.PI / 2, true);
            ctx.lineTo(leftCenterX, 2 * r * scale + cameraOffsetY);
            ctx.arc(leftCenterX, centerY, r * scale, Math.PI / 2, 3 * Math.PI / 2, true);
            ctx.stroke();
          }
        }

        // Main loop
        function gameLoop(timestamp) {
          if (!lastTimestamp) lastTimestamp = timestamp;
          const dt = (timestamp - lastTimestamp) / 1000;
          lastTimestamp = timestamp;

          if (raceStarted && !raceFinished) {
            runners.forEach(runner => runner.update(dt));
          }

          drawTrack();
          runners.forEach(runner => runner.draw());

          requestAnimationFrame(gameLoop);
        }

        // Event listeners for debug and controls (e.g., toggle debug with 'D')
        document.addEventListener('keydown', e => {
          if (e.key === 'd') debugMode = !debugMode;
          if (e.key === 's' && !raceStarted) initializeRace(1, 400); // Start example race
        });

        // Start the loop (initialize a sample race for demo)
        initializeRace(1, 400);
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stickman Animation Preview</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for sound effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles for the canvas to ensure it scales responsively */
        canvas {
            display: block;
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            max-width: 800px; /* Optional: limit max width for very large screens */
            margin: 0 auto; /* Center the canvas */
            border: 1px solid #ccc;
            background: #fff;
            border-radius: 0.5rem; /* Rounded corners for the canvas */
        }
        /* Ensure the body uses Inter font */
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-100 to-purple-100 min-h-screen flex flex-col items-center justify-center p-4 relative">
    <!-- Back Button -->
    <button onclick="window.location.href='https://zapback100.github.io/Dads-Games/index.html'"
            class="absolute top-4 left-4 bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 z-10">
        Back
    </button>

    <div class="flex flex-row items-center justify-center gap-4 mb-4">
        <button id="toggleControls" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
            Toggle Controls
        </button>
        <label for="difficulty" class="flex items-center space-x-2">
            <span class="font-semibold text-gray-800">Difficulty:</span>
            <select id="difficulty" class="mt-1 block pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
                <option value="easy">Easy</option>
                <option value="medium" selected>Medium</option>
                <option value="hard">Hard</option>
            </select>
        </label>
        <!-- Player Name Input - Moved here -->
        <label for="playerName" class="flex items-center space-x-2">
            <span class="font-semibold text-gray-800">Your Name:</span>
            <input type="text" id="playerName" placeholder="Enter your name" class="mt-1 block w-full pl-3 pr-3 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
        </label>
    </div>

    <div id="ui-controls-container" class="bg-white p-6 rounded-xl shadow-lg mb-6 w-full max-w-4xl hidden">
        <p class="text-gray-700 mb-4 text-center text-sm sm:text-base">Press <span class="font-bold text-blue-600">SPACEBAR</span> to start/reset. Use A/D to move left/right, W to jump, S to crouch. In manual mode, alternate <span class="font-bold text-blue-600">X/C</span> for forward movement.</p>
        <div id="controls" class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm sm:text-base">
            <div class="flex flex-col space-y-2">
                <!-- Player Name Input was here, now moved above -->

                <label for="manualMode" class="flex items-center space-x-2 cursor-pointer">
                    <input type="checkbox" id="manualMode" class="form-checkbox h-4 w-4 text-blue-600 rounded focus:ring-blue-500" checked>
                    <span>Manual Run Mode</span>
                </label>

                <label for="maxManualSpeed" class="flex flex-col">
                    <span>Max Manual Speed (m/s): <span id="maxManualSpeedValue" class="font-semibold">10</span></span>
                    <input type="range" id="maxManualSpeed" min="1" max="15" step="0.5" value="10" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="strideLengthMultiplier" class="flex flex-col">
                    <span>Stride Length Multiplier: <span id="strideLengthMultiplierValue" class="font-semibold">1</span></span>
                    <input type="range" id="strideLengthMultiplier" min="0.5" max="2" step="0.05" value="1" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="accelDecelSmoothness" class="flex flex-col">
                    <span>Accel/Decel Smoothness: <span id="accelDecelSmoothnessValue" class="font-semibold">0.05</span></span>
                    <input type="range" id="accelDecelSmoothness" min="0.01" max="0.1" step="0.005" value="0.05" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="speed" class="flex flex-col">
                    <span>Speed (Non-Manual): <span id="speedValue" class="font-semibold">1</span></span>
                    <input type="range" id="speed" min="1" max="8" step="0.5" value="1" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="expression" class="flex flex-col">
                    <span>Expression:</span>
                    <select id="expression" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md shadow-sm">
                        <option value="neutral" selected>Neutral</option>
                        <option value="happy">Happy</option>
                        <option value="sad">Sad</option>
                        <option value="angry">Angry</option>
                        <option value="surprised">Surprised</option>
                        <option value="tired">Tired</option>
                        <option value="trying">Trying</option>
                    </select>
                </label>

                <label for="crouchExtraBend" class="flex flex-col">
                    <span>Crouch Extra Bend: <span id="crouchExtraBendValue" class="font-semibold">0.9</span></span>
                    <input type="range" id="crouchExtraBend" min="0" max="1.5" step="0.05" value="0.9" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <strong class="mt-4 text-gray-800">Right Direction (dir=1):</strong>
                <label for="gaitAmplitude" class="flex flex-col">
                    <span>Gait Amplitude: <span id="gaitAmplitudeValue" class="font-semibold">0.9</span></span>
                    <input type="range" id="gaitAmplitude" min="0" max="2" step="0.05" value="0.9" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="stepFrequency" class="flex flex-col">
                    <span>Step Frequency: <span id="stepFrequencyValue" class="font-semibold">0.07</span></span>
                    <input type="range" id="stepFrequency" min="0.05" max="0.2" step="0.01" value="0.07" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="armSwingAmplitudeRight" class="flex flex-col">
                    <span>Right Arm Swing Amplitude: <span id="armSwingAmplitudeRightValue" class="font-semibold">0.4</span></span>
                    <input type="range" id="armSwingAmplitudeRight" min="0" max="1" step="0.05" value="0.4" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>
            </div>

            <div class="flex flex-col space-y-2">
                <label for="frontKneeBend" class="flex flex-col">
                    <span>Front Knee Bend: <span id="frontKneeBendValue" class="font-semibold">0.3</span></span>
                    <input type="range" id="frontKneeBend" min="0" max="1" step="0.05" value="0.3" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMax" class="flex flex-col">
                    <span>Back Knee Bend Max: <span id="backKneeBendMaxValue" class="font-semibold">0.7</span></span>
                    <input type="range" id="backKneeBendMax" min="0" max="1.5" step="0.05" value="0.7" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMultiplier" class="flex flex-col">
                    <span>Back Knee Bend Multiplier: <span id="backKneeBendMultiplierValue" class="font-semibold">2.5</span></span>
                    <input type="range" id="backKneeBendMultiplier" min="1" max="4" step="0.1" value="2.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="elbowBend" class="flex flex-col">
                    <span>Elbow Bend: <span id="elbowBendValue" class="font-semibold">1.75</span></span>
                    <input type="range" id="elbowBend" min="0" max="4" step="0.05" value="1.75" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="armSwingAmplitude" class="flex flex-col">
                    <span>Arm Swing Amplitude (Computers): <span id="armSwingAmplitudeValue" class="font-semibold">0.7</span></span>
                    <input type="range" id="armSwingAmplitude" min="0" max="1" step="0.05" value="0.7" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="torsoThickness" class="flex flex-col">
                    <span>Torso Thickness: <span id="torsoThicknessValue" class="font-semibold">2</span></span>
                    <input type="range" id="torsoThickness" min="1" max="10" step="0.5" value="2" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <strong class="mt-4 text-gray-800">Left Direction (dir=-1):</strong>
                <label for="gaitAmplitudeLeft" class="flex flex-col">
                    <span>Gait Amplitude Left: <span id="gaitAmplitudeLeftValue" class="font-semibold">0.9</span></span>
                    <input type="range" id="gaitAmplitudeLeft" min="0" max="2" step="0.05" value="0.9" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="stepFrequencyLeft" class="flex flex-col">
                    <span>Step Frequency Left: <span id="stepFrequencyLeftValue" class="font-semibold">0.07</span></span>
                    <input type="range" id="stepFrequencyLeft" min="0.05" max="0.2" step="0.01" value="0.07" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="frontKneeBendLeft" class="flex flex-col">
                    <span>Front Knee Bend Left: <span id="frontKneeBendLeftValue" class="font-semibold">0.3</span></span>
                    <input type="range" id="frontKneeBendLeft" min="0" max="1" step="0.05" value="0.3" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMaxLeft" class="flex flex-col">
                    <span>Back Knee Bend Max Left: <span id="backKneeBendMaxLeftValue" class="font-semibold">0.7</span></span>
                    <input type="range" id="backKneeBendMaxLeft" min="0" max="1.5" step="0.05" value="0.7" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="backKneeBendMultiplierLeft" class="flex flex-col">
                    <span>Back Knee Bend Multiplier Left: <span id="backKneeBendMultiplierLeftValue" class="font-semibold">2.5</span></span>
                    <input type="range" id="backKneeBendMultiplierLeft" min="1" max="4" step="0.1" value="2.5" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="elbowBendLeft" class="flex flex-col">
                    <span>Elbow Bend Left: <span id="elbowBendLeftValue" class="font-semibold">3</span></span>
                    <input type="range" id="elbowBendLeft" min="0" max="4" step="0.05" value="3" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="torsoThicknessLeft" class="flex flex-col">
                    <span>Torso Thickness Left: <span id="torsoThicknessLeftValue" class="font-semibold">3</span></span>
                    <input type="range" id="torsoThicknessLeft" min="1" max="10" step="0.5" value="3" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>

                <label for="armSwingAmplitudeLeft" class="flex flex-col">
                    <span>Left Arm Swing Amplitude: <span id="armSwingAmplitudeLeftValue" class="font-semibold">0.7</span></span>
                    <input type="range" id="armSwingAmplitudeLeft" min="0" max="1" step="0.05" value="0.7" class="w-full h-2 bg-blue-100 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </label>
            </div>
        </div>
        <div class="mt-4 text-center text-sm sm:text-base">
            <p>Current Speed: <span id="currentSpeedDisplay" class="font-bold">0.00 m/s</span></p>
            <p>Tapping Frequency: <span id="tappingFrequencyDisplay" class="font-bold">0.00 taps/s</span></p>
        </div>
    </div>
    <canvas id="c" width="600" height="400" class="shadow-xl"></canvas>
    <script>
        // Global variable for number of lanes
        const numLanes = 8;

        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('c');
            const ctx = canvas.getContext('2d');
            const speedSelect = document.getElementById('speed');
            const expressionSelect = document.getElementById('expression');
            const manualModeCheckbox = document.getElementById('manualMode');
            const maxManualSpeedSelect = document.getElementById('maxManualSpeed');
            const strideLengthMultiplierSelect = document.getElementById('strideLengthMultiplier'); // New slider
            const accelDecelSmoothnessSelect = document.getElementById('accelDecelSmoothness'); // New slider
            const armSwingAmplitudeSelect = document.getElementById('armSwingAmplitude');
            const armSwingAmplitudeRightSelect = document.getElementById('armSwingAmplitudeRight');
            const armSwingAmplitudeLeftSelect = document.getElementById('armSwingAmplitudeLeft');
            const uiControlsContainer = document.getElementById('ui-controls-container');
            const toggleControlsButton = document.getElementById('toggleControls');
            const difficultySelect = document.getElementById('difficulty'); // Difficulty dropdown
            const playerNameInput = document.getElementById('playerName'); // Player Name Input

            const currentSpeedDisplay = document.getElementById('currentSpeedDisplay');
            const tappingFrequencyDisplay = document.getElementById('tappingFrequencyDisplay');


            let keys = {};

            // Define pacing strategies
            const pacingStrategies = ['even', 'fast_finish', 'slow_finish', 'middle_burst', 'random_fluctuate'];
            const computerNames = [
                "Bolt", "Flash", "Cheetah", "Gazelle", "Rocket", "Dash", "Sprinter",
                "Blaze", "Sonic", "Mercury", "Swift", "Pace", "Stride", "RunnerX",
                "Turbo", "Velocity", "Quickstep", "Windrunner", "Shadow", "Phantom"
            ];
            let usedNames = new Set(); // To ensure unique names for each race

            let currentDifficulty = difficultySelect.value; // Initialize difficulty

            // Function to get a random pacing strategy
            function getRandomPacingStrategy() {
                return pacingStrategies[Math.floor(Math.random() * pacingStrategies.length)];
            }

            // Function to get a unique random name
            function getUniqueRandomName() {
                if (usedNames.size === computerNames.length) {
                    usedNames.clear(); // Reset if all names are used
                }
                let name;
                do {
                    name = computerNames[Math.floor(Math.random() * computerNames.length)];
                } while (usedNames.has(name));
                usedNames.add(name);
                return name;
            }

            // Function to generate a random base speed for computers based on difficulty
            function getRandomBaseSpeedMps(difficulty) {
                switch (difficulty) {
                    case 'easy':
                        return 2.5 + Math.random() * 1.5; // Slower range: 2.5 - 4.0 m/s
                    case 'medium':
                        // Adjusted range for medium difficulty
                        return 2.8 + Math.random() * 1.5; // Range: 2.8 - 4.3 m/s
                    case 'hard':
                        // Adjusted range for hard difficulty to target ~24s for 100m (avg 4.16 m/s)
                        return 3.5 + Math.random() * 0.6; // Range: 3.5 - 4.1 m/s
                    default:
                        return 3.0 + Math.random() * 2.0; // Default to medium
                }
            }

            // Function to create a new computer runner
            function createComputerRunner(laneId, difficulty) {
                let speedVarianceMps, fatigueRate, recoveryRate;

                switch (difficulty) {
                    case 'easy':
                        speedVarianceMps = 0.05 + Math.random() * 0.1; // Less variance
                        fatigueRate = 0.00003 + Math.random() * 0.00003; // Slower fatigue
                        recoveryRate = 0.00006 + Math.random() * 0.00006; // Faster recovery
                        break;
                    case 'medium':
                        speedVarianceMps = 0.08 + Math.random() * 0.12; // Slightly less variance than hard
                        fatigueRate = 0.00005 + Math.random() * 0.00005; // Slightly slower fatigue than hard
                        recoveryRate = 0.00005 + Math.random() * 0.00005; // Slightly faster recovery than hard
                        break;
                    case 'hard':
                        speedVarianceMps = 0.12 + Math.random() * 0.18; // More variance
                        fatigueRate = 0.00007 + Math.random() * 0.00007; // Faster fatigue
                        recoveryRate = 0.00003 + Math.random() * 0.00003; // Slower recovery
                        break;
                    default: // Default to medium
                        speedVarianceMps = 0.1 + Math.random() * 0.15;
                        fatigueRate = 0.00006 + Math.random() * 0.00006;
                        recoveryRate = 0.00004 + Math.random() * 0.00004;
                }

                return {
                    id: getUniqueRandomName(), // Assign a unique name
                    lane: laneId,
                    position: 0,
                    y: 0,
                    vy: 0,
                    dir: 1,
                    onGround: true,
                    stepCycle: 0,
                    isCrouching: false,
                    isFinished: false,
                    reachedRelaxPoint: false,
                    startTime: 0,
                    finishTime: 0,
                    isPlayer: false,
                    expression: 'neutral', // Default expression for computers
                    baseSpeedMps: getRandomBaseSpeedMps(difficulty),
                    speedVarianceMps: speedVarianceMps,
                    color: '#000',
                    legColor: `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`, // Random leg color
                    finalIdleX: 0,
                    currentVx: 0,
                    desiredVx: 0,
                    pacingStrategy: getRandomPacingStrategy(), // Assign a random strategy
                    paceFactor: 0.9 + Math.random() * 0.2, // Initial random pace between 0.9 and 1.1
                    paceChangeTimer: 0,
                    paceChangeInterval: 1000 + Math.random() * 2000, // Change pace every 1-3 seconds
                    fatigue: 0, // Accumulates fatigue
                    fatigueRate: fatigueRate,
                    recoveryRate: recoveryRate,
                    burstCooldown: 0, // Cooldown for speed bursts
                    burstDuration: 0, // How long the current burst lasts
                    prevPosition: 0 // To track overtakes
                };
            }

            // Runner data structure
            let runners = [];

            function initializeRunners() {
                const playerName = playerNameInput.value.trim(); // Get player name from input
                runners = [
                    // Player runner
                    {
                        id: playerName === '' ? 'Player' : playerName, // Use entered name or default
                        lane: 2,
                        position: 0,
                        y: 0, // Calculated dynamically
                        vy: 0,
                        dir: 1,
                        onGround: true,
                        stepCycle: 0,
                        isCrouching: false,
                        isFinished: false, // True when crosses finish line
                        reachedRelaxPoint: false, // True when crosses finishLine + 2m
                        startTime: 0,
                        finishTime: 0,
                        isPlayer: true,
                        expression: 'neutral', // Player's expression
                        color: '#000', // Body color (black)
                        legColor: '#000', // Black legs for player (hip to knee)
                        finalIdleX: 0, // To store the final random idle position
                        tapTimes: [], // Store timestamps of recent taps
                        tapFrequency: 0, // Calculated taps per second
                        currentVx: 0, // Current horizontal velocity
                        desiredVx: 0, // Target horizontal velocity
                        isCelebrating: false, // For celebration animation
                        celebrationStartTime: 0,
                        prevPosition: 0 // To track overtakes
                    }
                ];

                // Add computer runners to all other lanes
                for (let i = 1; i <= numLanes; i++) {
                    if (i !== 2) { // Player is in lane 2
                        runners.push(createComputerRunner(i, currentDifficulty));
                    }
                }
                // Sort runners by lane for consistent drawing order
                runners.sort((a, b) => a.lane - b.lane);
            }

            initializeRunners(); // Initial setup of runners

            let blinkTimer = 0;
            let isBlinking = false;
            let nextBlinkTime = getNextBlinkTime();

            let lastTapKey = ''; // To enforce alternating X/C taps

            // Game State variables
            let gameState = 'idle'; // 'idle', 'countdown', 'running', 'finished'

            // Top Times variables
            let bestTimes = []; // Stores the top 3 times in milliseconds

            // Countdown message variables for canvas drawing
            let currentCountdownMessage = '';
            let countdownMessageEndTime = 0;

            // Tone.js setup for sound effects
            const synth = new Tone.Synth().toDestination();
            const crowdPlayer = new Tone.Player({
                url: "https://raw.githubusercontent.com/zapback100/Dads-Games/main/large-crowd-applause-6250.mp3",
                loop: true,
                autostart: false, // We'll start it manually
                volume: -30 // Start very low
            }).toDestination();

            const beepFrequencies = {
                'Ready!': 'C4', // Middle C
                'Set!': 'D4',   // D above middle C
                'Go!': 'G4'     // G above middle C
            };

            // Function to resume audio context on user interaction
            function resumeAudioContext() {
                if (Tone.context.state !== 'running') {
                    Tone.context.resume();
                }
            }
            // Add a listener for any user interaction to resume audio
            document.addEventListener('click', resumeAudioContext, { once: true });
            document.addEventListener('keydown', resumeAudioContext, { once: true });


            // Fixed ground line (relative to canvas height)
            const groundYRatio = 300 / 400; // Original ratio
            let groundY; // Will be calculated based on current canvas height


            let laneHeight; // Will be calculated dynamically

            // Leg constants (consistent lengths for walking and crouching)
            const upperLegLen = 20;
            const lowerLegLen = 25;
            const footRadius = 2;
            const footHeight = footRadius * 2;

            // Arm constants
            const upperArmLen = 19.36;
            const lowerArmLen = 19.36;

            // Global variable for pixels per meter, updated in updateDimensions
            let pixelsPerMeter = 50; // 50 pixels per meter

            // Cloud data - initial positions and parallax factors
            const clouds = [
                { initialX: 100, y: 50, width: 60, height: 30, parallaxFactor: 0.1 },
                { initialX: 300, y: 80, width: 80, height: 40, parallaxFactor: 0.05 },
                { initialX: 550, y: 60, width: 70, height: 35, parallaxFactor: 0.08 },
                { initialX: 700, y: 90, width: 50, height: 25, parallaxFactor: 0.12 }
            ];

            // Function to update dimensions based on current canvas size
            function updateDimensions() {
                groundY = canvas.height * groundYRatio;
                laneHeight = (canvas.height - groundY) / numLanes;
                pixelsPerMeter = 50 * (canvas.width / 600); // Update scaled pixelsPerMeter
            }

            // Function to resize canvas
            function resizeCanvas() {
                const containerWidth = canvas.parentElement.clientWidth;
                const newWidth = Math.min(containerWidth, 800);
                const newHeight = (newWidth / 3) * 2;

                canvas.width = newWidth;
                canvas.height = newHeight;
                updateDimensions(); // Update dimensions before drawing
                draw(); // Redraw content after resizing
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas(); // Call once to set initial dimensions

            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;

                if (e.key.toLowerCase() === ' ') {
                    if (gameState === 'idle' || gameState === 'finished') {
                        startCountdown();
                    } else if (gameState === 'running') {
                        resetGame();
                    }
                }

                // Player movement inputs only if game is running or if player has finished and can still move
                if (gameState === 'running' || (runners.find(r => r.isPlayer) && runners.find(r => r.isPlayer).reachedRelaxPoint === true)) {
                    const player = runners.find(r => r.isPlayer);
                    if (!player) return;

                    if (manualModeCheckbox.checked) {
                        const now = performance.now();
                        let tapDetected = false;

                        if ((e.key.toLowerCase() === 'x' && lastTapKey !== 'x') || (e.key.toLowerCase() === 'c' && lastTapKey !== 'c')) {
                            // Enforce alternating taps (X then C, or C then X)
                            if ((e.key.toLowerCase() === 'x' && lastTapKey === 'c') || (e.key.toLowerCase() === 'c' && lastTapKey === 'x') || lastTapKey === '') {
                                player.tapTimes.push(now);
                                // Keep only the last 5 taps for frequency calculation
                                if (player.tapTimes.length > 5) {
                                    player.tapTimes.shift();
                                }
                                lastTapKey = e.key.toLowerCase();
                                tapDetected = true;
                            }
                        }

                        if (tapDetected) {
                            // Calculate tapping frequency
                            if (player.tapTimes.length > 1) {
                                const timeSpan = (player.tapTimes[player.tapTimes.length - 1] - player.tapTimes[0]) / 1000; // in seconds
                                player.tapFrequency = (player.tapTimes.length - 1) / timeSpan;
                            } else {
                                player.tapFrequency = 0;
                            }

                            // Update desiredVx based on tap frequency
                            const maxManualSpeedMps = parseFloat(maxManualSpeedSelect.value); // Max speed in m/s from slider
                            const maxTapFrequencyForFullSpeed = 6.5; // User specified: 6.5 taps/s for 100m in ~10s

                            // Calculate desired speed in m/s based on tap frequency
                            let desiredSpeedMps = (player.tapFrequency / maxTapFrequencyForFullSpeed) * maxManualSpeedMps;
                            desiredSpeedMps = Math.min(maxManualSpeedMps, desiredSpeedMps); // Cap at max slider value

                            // Convert desired speed from m/s to px/frame
                            player.desiredVx = (desiredSpeedMps * pixelsPerMeter) / 60; // Assuming 60 frames per second

                            player.dir = 1; // Always move forward
                            // stepCycle is now updated continuously in the update loop based on currentVx
                        }
                    }
                }
            });
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

            function getSpeed() {
                return parseFloat(speedSelect.value);
            }

            function getNextBlinkTime() {
                return performance.now() + 3000 + Math.random() * 2000;
            }

            function calculateComputerTargetSpeed(runner, raceProgressRatio) {
                let targetSpeedMps = runner.baseSpeedMps;

                // Apply base randomness
                targetSpeedMps += (Math.random() - 0.5) * runner.speedVarianceMps;

                // Update pace factor and fatigue
                runner.paceChangeTimer -= (1000 / 60); // Decrement timer by frame time (approx 16.67ms)
                if (runner.paceChangeTimer <= 0) {
                    runner.paceChangeTimer = runner.paceChangeInterval;
                    // Randomly adjust pace factor more aggressively for 'random_fluctuate'
                    const adjustment = (runner.pacingStrategy === 'random_fluctuate') ? (Math.random() * 0.4 - 0.2) : (Math.random() * 0.2 - 0.1);
                    runner.paceFactor += adjustment;
                    runner.paceFactor = Math.max(0.7, Math.min(1.3, runner.paceFactor)); // Wider bounds for more dynamic pacing
                }

                // Apply fatigue effect
                const currentSpeedMps = (runner.currentVx / pixelsPerMeter) * 60;
                if (currentSpeedMps > runner.baseSpeedMps * runner.paceFactor) { // Fatigue increases if pushing harder than current pace factor
                    runner.fatigue += runner.fatigueRate;
                } else {
                    runner.fatigue = Math.max(0, runner.fatigue - runner.recoveryRate);
                }
                // Fatigue directly reduces the effective speed
                targetSpeedMps = Math.max(0.5, targetSpeedMps * (1 - Math.min(0.5, runner.fatigue))); // Cap fatigue impact to 50% speed reduction

                // Apply random bursts (can be independent of pacing strategy or integrated)
                if (runner.burstCooldown <= 0 && Math.random() < 0.002) { // Slightly higher chance for a burst
                    runner.burstDuration = 60 + Math.random() * 120; // Burst for 1-2 seconds (60 frames/sec)
                    runner.burstCooldown = 300 + Math.random() * 300; // Cooldown for 5-10 seconds
                }
                if (runner.burstDuration > 0) {
                    targetSpeedMps = Math.min(runner.baseSpeedMps * 1.5, targetSpeedMps * 1.15); // Small boost during burst
                    runner.burstDuration--;
                } else {
                    runner.burstCooldown--;
                }

                // Ensure speed is within a reasonable overall range
                return Math.max(0.5, Math.min(5.5, targetSpeedMps)); // Overall cap for computer speeds, slightly increased
            }

            function update() {
                const finishLineMeter = 100;
                const finishLinePosition = finishLineMeter * pixelsPerMeter;
                const relaxDistance = 2 * pixelsPerMeter; // 2 meters past the finish line
                const scaledHeight = canvas.height / 400;
                const accelDecelSmoothness = parseFloat(accelDecelSmoothnessSelect.value);

                const player = runners.find(r => r.isPlayer);

                runners.forEach(runner => {
                    // Store previous position for overtake detection
                    runner.prevPosition = runner.position;

                    const runnerGroundY = groundY + (runner.lane - 1) * laneHeight + laneHeight / 2;
                    const maxLegHeight = upperLegLen + lowerLegLen + footHeight;

                    // Only allow movement if game is in 'running' state
                    if (gameState === 'running') {
                        if (runner.isPlayer) {
                            // Handle manual mode speed and deceleration
                            if (manualModeCheckbox.checked) {
                                // If no relevant keys are pressed, gradually reduce desiredVx to 0
                                if (!keys['x'] && !keys['c']) {
                                    runner.desiredVx = 0;
                                    lastTapKey = ''; // Reset last tap key when no keys are pressed
                                }

                                // Smoothly interpolate currentVx towards desiredVx
                                runner.currentVx += (runner.desiredVx - runner.currentVx) * accelDecelSmoothness;

                                // If currentVx is very small and desiredVx is 0, set to 0 to prevent infinite slowdown
                                if (Math.abs(runner.currentVx) < 0.01 && runner.desiredVx === 0) {
                                    runner.currentVx = 0;
                                    runner.stepCycle = 0; // Stop animation if not moving
                                } else if (runner.currentVx !== 0) {
                                    // Advance stepCycle based on current speed for smooth animation
                                    const currentStepFrequency = parseFloat(document.getElementById('stepFrequency').value);
                                    runner.stepCycle += Math.abs(runner.currentVx) * currentStepFrequency;
                                }

                                runner.position += runner.currentVx; // Update position based on current smooth velocity
                                runner.isCrouching = keys['s'] && runner.onGround;
                                if (keys['w'] && runner.onGround) {
                                    runner.vy = -12;
                                    runner.onGround = false;
                                }
                            } else { // Non-manual mode (A/D keys)
                                let desiredVx = 0;
                                if (keys['a']) {
                                    desiredVx -= getSpeed();
                                    runner.dir = -1;
                                }
                                if (keys['d']) {
                                    desiredVx += getSpeed();
                                    runner.dir = 1;
                                }
                                runner.currentVx += (desiredVx - runner.currentVx) * accelDecelSmoothness;
                                if (Math.abs(runner.currentVx) < 0.01 && desiredVx === 0) {
                                    runner.currentVx = 0;
                                    runner.stepCycle = 0;
                                } else if (runner.currentVx !== 0) {
                                    const currentStepFrequency = (runner.dir === 1) ? parseFloat(document.getElementById('stepFrequency').value) : parseFloat(document.getElementById('stepFrequencyLeft').value);
                                    runner.stepCycle += Math.abs(runner.currentVx) * currentStepFrequency;
                                }
                                runner.position += runner.currentVx;
                                runner.isCrouching = keys['s'] && runner.onGround;
                                if (keys['w'] && runner.onGround) {
                                    runner.vy = -12;
                                    runner.onGround = false;
                                }
                            }

                            // Player celebration logic
                            if (runner.isCelebrating) {
                                const now = performance.now();
                                const celebrationDuration = 3000; // 3 seconds
                                if (now - runner.celebrationStartTime > celebrationDuration) {
                                    runner.isCelebrating = false; // End celebration
                                }
                            }

                        } else { // Computer runner AI
                            let targetSpeedMps = 0; // Target speed in m/s
                            if (!runner.reachedRelaxPoint) { // Only move if not reached relax point
                                const raceProgressRatio = runner.position / finishLinePosition; // 0 to 1
                                targetSpeedMps = calculateComputerTargetSpeed(runner, raceProgressRatio);
                                runner.dir = 1;
                                runner.isCrouching = false;

                                // Update computer expression based on performance
                                if (runner.fatigue > 0.5) {
                                    runner.expression = 'tired';
                                } else if (raceProgressRatio < 0.2 && runner.currentVx < runner.baseSpeedMps * 0.8) {
                                    runner.expression = 'sad'; // Slow start
                                } else if (raceProgressRatio > 0.7 && runner.currentVx > runner.baseSpeedMps * 1.1) {
                                    runner.expression = 'trying'; // Strong finish
                                } else {
                                    runner.expression = 'neutral';
                                }
                            } else {
                                targetSpeedMps = 0; // Stop if relax point reached
                            }

                            // Convert targetSpeedMps to px/frame
                            runner.desiredVx = (targetSpeedMps * pixelsPerMeter) / 60;

                            // Smoothly update computer's currentVx
                            runner.currentVx += (runner.desiredVx - runner.currentVx) * accelDecelSmoothness * 2; // Computers react faster
                            if (Math.abs(runner.currentVx) < 0.01 && runner.desiredVx === 0) {
                                runner.currentVx = 0;
                                runner.stepCycle = 0;
                            } else if (runner.currentVx !== 0) {
                                const currentStepFrequency = parseFloat(document.getElementById('stepFrequency').value);
                                runner.stepCycle += Math.abs(runner.currentVx) * currentStepFrequency;
                            }
                            runner.position += runner.currentVx;

                            // Ensure it doesn't overshoot the finalIdleX if stopping
                            if (runner.reachedRelaxPoint && Math.abs(runner.position - runner.finalIdleX) < Math.abs(runner.currentVx)) {
                                runner.position = runner.finalIdleX;
                                runner.currentVx = 0;
                                runner.stepCycle = 0;
                            }
                        }
                    } else { // If not running, ensure no movement for any runner
                        runner.currentVx = 0;
                        runner.desiredVx = 0;
                        runner.stepCycle = 0;
                        runner.isCrouching = false;
                        // Keep player's expression based on UI, computer's neutral
                        if (!runner.isPlayer) runner.expression = 'neutral';
                    }


                    // Apply gravity and update vertical position (applies to all runners)
                    // This should always happen, even if not moving horizontally, for jumping/landing
                    runner.vy += 0.6;
                    runner.y += runner.vy;

                    // Collision with ground (applies to all runners)
                    if (runner.y + maxLegHeight * scaledHeight >= runnerGroundY) {
                        runner.y = runnerGroundY - maxLegHeight * scaledHeight;
                        runner.vy = 0;
                        runner.onGround = true;
                    }

                    // Add bobbing for running on ground (applies if moving)
                    if (runner.onGround && runner.currentVx !== 0) {
                        runner.y += Math.sin(runner.stepCycle) * 3 * scaledHeight;
                    }

                    // Check for finish line (always applies if not finished)
                    if (runner.position >= finishLinePosition && !runner.isFinished) {
                        runner.isFinished = true;
                        runner.finishTime = performance.now();
                        addTimeToBestTimes(runner.finishTime - runner.startTime, runner.id);

                        // Trigger happy expression for computer runners if they finish in top 3
                        const rank = bestTimes.findIndex(bt => bt.id === runner.id);
                        if (!runner.isPlayer && rank !== -1 && rank < 3) {
                            runner.expression = 'happy';
                        }
                        // Trigger player celebration
                        if (runner.isPlayer && rank !== -1 && rank < 3) {
                            runner.isCelebrating = true;
                            runner.celebrationStartTime = performance.now();
                        }

                        // Increase crowd volume for finishers
                        crowdPlayer.volume.rampTo(Math.min(crowdPlayer.volume.value + 5, 0), 0.5); // Boost volume
                    }

                    // Check for relax point (always applies if finished but not reached relax point)
                    if (runner.isFinished && runner.position >= (finishLinePosition + relaxDistance) && !runner.reachedRelaxPoint) {
                        runner.reachedRelaxPoint = true;
                        if (!runner.isPlayer) { // Only set finalIdleX for computers
                            runner.finalIdleX = runner.position; // Store current position as final idle X
                        }
                    }
                });

                // Overtake cheering logic for player
                if (gameState === 'running' && player) {
                    runners.forEach(otherRunner => {
                        if (!otherRunner.isPlayer && !otherRunner.isFinished) {
                            // Check if player was behind and is now ahead
                            if (player.prevPosition < otherRunner.prevPosition && player.position > otherRunner.position) {
                                crowdPlayer.volume.rampTo(5, 0.2); // Brief loud burst
                                crowdPlayer.volume.rampTo(-10, 1); // Return to normal after 1 second
                            }
                        }
                    });
                }


                // Check if all runners have reached their relax point to set overall game state to 'finished'
                if (runners.every(r => r.reachedRelaxPoint)) {
                    if (gameState !== 'finished') { // Only fade out once
                        gameState = 'finished';
                        crowdPlayer.volume.rampTo(-30, 5); // Fade out over 5 seconds
                        crowdPlayer.stop("+5"); // Stop after fade out
                    }
                }

                const now = performance.now();
                if (!isBlinking && now > nextBlinkTime) {
                    isBlinking = true;
                    blinkTimer = now + 150;
                }
                if (isBlinking && now > blinkTimer) {
                    isBlinking = false;
                    nextBlinkTime = getNextBlinkTime();
                }

                // Update UI displays for manual runner
                if (player) {
                    const speedMps = (player.currentVx / pixelsPerMeter) * 60; // Convert px/frame to m/s (assuming 60fps)
                    currentSpeedDisplay.textContent = speedMps.toFixed(2) + ' m/s';
                    tappingFrequencyDisplay.textContent = player.tapFrequency.toFixed(2) + ' taps/s';
                }
            }

            function formatTime(milliseconds) {
                const totalSeconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const centiseconds = Math.floor((milliseconds % 1000) / 10);

                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(centiseconds).padStart(2, '0')}`;
            }

            // This function now draws the stopwatch for the player
            function drawStopwatch() {
                const player = runners.find(r => r.isPlayer);
                let timeToDisplay = '00:00.00';
                if (player) {
                    // Only display elapsed time if the game is running
                    if (gameState === 'running') {
                        const elapsedTime = performance.now() - player.startTime;
                        timeToDisplay = formatTime(elapsedTime);
                    } else if (player.isFinished) { // If finished, show final time
                        timeToDisplay = formatTime(player.finishTime - player.startTime);
                    }
                    // Otherwise, it remains '00:00.00' as initialized
                }

                ctx.save();
                ctx.fillStyle = 'black';
                ctx.font = `${24 * (canvas.width / 600)}px 'Fira Code', monospace`;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';

                const padding = 10 * (canvas.width / 600);
                ctx.fillText(timeToDisplay, canvas.width - padding, padding);
                ctx.restore();
            }

            // Function to add a new time to the best times list and keep it sorted
            function addTimeToBestTimes(time, runnerId) {
                bestTimes.push({ time: time, id: runnerId });
                bestTimes.sort((a, b) => a.time - b.time); // Sort ascending (fastest times first)
                // Keep only the top 3 times
                if (bestTimes.length > 3) {
                    bestTimes.splice(3);
                }
            }

            // Function to get ordinal suffix for numbers
            function getOrdinalSuffix(i) {
                const j = i % 10,
                      k = i % 100;
                if (j === 1 && k !== 11) {
                    return "st";
                }
                if (j === 2 && k !== 12) {
                    return "nd";
                }
                if (j === 3 && k !== 13) {
                    return "rd";
                }
                return "th";
            }

            // Function to draw the best times list on the canvas
            function drawBestTimes() {
                ctx.save();
                ctx.fillStyle = 'black';
                ctx.font = `${16 * (canvas.width / 600)}px Arial`;
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';

                const padding = 10 * (canvas.width / 600);
                let yOffset = padding;

                if (bestTimes.length > 0) {
                    ctx.fillText('Top Times:', padding, yOffset);
                    yOffset += 20 * (canvas.width / 600);

                    bestTimes.forEach((entry, index) => {
                        let rankText = `${index + 1}${getOrdinalSuffix(index + 1)}.`;
                        let medal = '';
                        if (index === 0) medal = '�';
                        else if (index === 1) medal = '🥈';
                        else if (index === 2) medal = '🥉';

                        ctx.fillText(`${rankText} ${medal} ${entry.id}: ${formatTime(entry.time)}`, padding, yOffset);
                        yOffset += 20 * (canvas.width / 600);
                    });
                }
                ctx.restore();
            }

            // New function to draw the countdown message on the canvas
            function drawCountdownMessage() {
                const now = performance.now();
                if (currentCountdownMessage && now < countdownMessageEndTime) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    ctx.font = `${60 * (canvas.width / 600)}px Arial Black`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    const fadeDuration = 300;
                    const remainingTime = countdownMessageEndTime - now;
                    let opacity = 1;
                    if (remainingTime < fadeDuration) {
                        opacity = remainingTime / fadeDuration;
                    }
                    ctx.globalAlpha = opacity;

                    ctx.fillText(currentCountdownMessage, canvas.width / 2, canvas.height / 2);
                    ctx.restore();
                }
            }

            function showCountdownMessage(message, duration = 500) {
                currentCountdownMessage = message;
                countdownMessageEndTime = performance.now() + duration;

                if (beepFrequencies[message]) {
                    synth.triggerAttackRelease(beepFrequencies[message], '8n');
                }
            }

            function startCountdown() {
                gameState = 'countdown';
                // Reset all runner states for a new race
                runners.forEach(runner => {
                    // Initial position slightly behind the start line
                    runner.position = -30 * (canvas.width / 600); // Adjusted for better "behind the line"
                    runner.isFinished = false;
                    runner.reachedRelaxPoint = false;
                    runner.startTime = 0; // Will be set to actual start time later
                    runner.finishTime = 0;
                    runner.stepCycle = 0;
                    runner.dir = 1;
                    runner.vy = 0;
                    runner.onGround = true;
                    runner.isCrouching = false;
                    runner.currentVx = 0; // Reset current velocity
                    runner.desiredVx = 0; // Reset desired velocity
                    runner.tapTimes = []; // Clear tap history
                    runner.tapFrequency = 0; // Reset tap frequency
                    // Initialize runner.y for standing idle pose
                    const runnerGroundY = groundY + (runner.lane - 1) * laneHeight + laneHeight / 2;
                    const maxLegHeight = upperLegLen + lowerLegLen + footHeight;
                    // Adjust initial Y for the "ready to run" pose
                    runner.y = runnerGroundY - maxLegHeight * (canvas.height / 400) + 10 * (canvas.height / 400); // Slightly lower for crouch

                    // Reset computer-specific pacing variables
                    if (!runner.isPlayer) {
                        runner.paceFactor = 0.9 + Math.random() * 0.2; // Random initial pace between 0.9 and 1.1
                        runner.fatigue = 0;
                        runner.burstCooldown = 0;
                        runner.burstDuration = 0;
                        runner.paceChangeTimer = runner.paceChangeInterval; // Reset timer
                        runner.expression = 'neutral'; // Reset computer expression
                    } else {
                        runner.isCelebrating = false; // Reset player celebration
                        runner.expression = 'neutral';
                    }
                });
                lastTapKey = ''; // Reset for new race
                bestTimes = []; // Clear top times for new race

                // Update the player's name before starting the countdown
                const player = runners.find(r => r.isPlayer);
                if (player) {
                    player.id = playerNameInput.value.trim() === '' ? 'Player' : playerNameInput.value.trim();
                }

                // Start crowd sound
                Tone.context.resume().then(() => {
                    if (crowdPlayer.state !== 'started') {
                        crowdPlayer.start();
                    }
                    crowdPlayer.volume.rampTo(-10, 5); // Fade in to -10dB over 5 seconds
                });

                showCountdownMessage('Ready!', 700);
                setTimeout(() => {
                    showCountdownMessage('Set!', 700);
                    setTimeout(() => {
                        showCountdownMessage('Go!', 700);
                        setTimeout(() => {
                            gameState = 'running';
                            const now = performance.now();
                            runners.forEach(runner => {
                                runner.startTime = now; // Set start time for all runners
                            });
                            currentCountdownMessage = '';
                        }, 700);
                    }, 1000);
                }, 1000);
            }

            function resetGame() {
                gameState = 'idle';
                initializeRunners(); // Re-initialize runners based on current difficulty
                runners.forEach(runner => {
                    runner.position = 0; // Reset to 0 for the idle state
                    runner.startTime = 0;
                    runner.isFinished = false;
                    runner.reachedRelaxPoint = false;
                    runner.finishTime = 0;
                    runner.stepCycle = 0;
                    runner.dir = 1;
                    runner.vy = 0;
                    runner.onGround = true;
                    runner.isCrouching = false;
                    runner.currentVx = 0; // Reset current velocity
                    runner.desiredVx = 0; // Reset desired velocity
                    runner.tapTimes = []; // Clear tap history
                    runner.tapFrequency = 0; // Reset tap frequency
                    // Initialize runner.y for idle state (standing tall)
                    const runnerGroundY = groundY + (runner.lane - 1) * laneHeight + laneHeight / 2;
                    const maxLegHeight = upperLegLen + lowerLegLen + footHeight;
                    runner.y = runnerGroundY - maxLegHeight * (canvas.height / 400);

                    // Reset computer-specific pacing variables
                    if (!runner.isPlayer) {
                        runner.paceFactor = 1.0;
                        runner.fatigue = 0;
                        runner.burstCooldown = 0;
                        runner.burstDuration = 0;
                        runner.paceChangeTimer = runner.paceChangeInterval;
                        runner.expression = 'neutral';
                    } else {
                        runner.isCelebrating = false;
                        runner.expression = 'neutral';
                    }
                });
                currentCountdownMessage = '';
                countdownMessageEndTime = 0;
                keys = {};
                lastTapKey = ''; // Reset for idle state
                bestTimes = []; // Clear top times
                crowdPlayer.stop(); // Stop sound on reset
                crowdPlayer.volume.value = -30; // Reset volume
            }

            // Function to draw clouds
            function drawClouds() {
                ctx.save();
                ctx.fillStyle = 'white';
                clouds.forEach(cloud => {
                    // Use player's position for parallax scrolling
                    const player = runners.find(r => r.isPlayer);
                    let renderX = cloud.initialX - (player.position * cloud.parallaxFactor);

                    // Wrap around the canvas width to create continuous scrolling
                    renderX = renderX % canvas.width;
                    if (renderX < -cloud.width * (canvas.width / 600)) {
                        renderX += canvas.width + cloud.width * (canvas.width / 600);
                    } else if (renderX > canvas.width) {
                        renderX -= canvas.width + cloud.width * (canvas.width / 600);
                    }

                    // Scale cloud dimensions and y position
                    const scaledWidth = cloud.width * (canvas.width / 600);
                    const scaledHeight = cloud.height * (canvas.height / 400);
                    const scaledY = cloud.y * (canvas.height / 400);

                    // Draw simple cloud shape using multiple circles
                    ctx.beginPath();
                    ctx.arc(renderX, scaledY, scaledWidth / 3, 0, Math.PI * 2);
                    ctx.arc(renderX + scaledWidth * 0.4, scaledY - scaledHeight * 0.3, scaledWidth / 3, 0, Math.PI * 2);
                    ctx.arc(renderX + scaledWidth * 0.7, scaledY, scaledWidth / 3, 0, Math.PI * 2);
                    ctx.arc(renderX + scaledWidth * 0.3, scaledY + scaledHeight * 0.3, scaledWidth / 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();
            }


            function drawGround() {
                ctx.fillStyle = '#87CEEB'; // Light blue
                ctx.fillRect(0, 0, canvas.width, groundY);

                drawClouds(); // Draw clouds after sky is painted

                ctx.fillStyle = '#228B22'; // Forest green
                ctx.fillRect(0, groundY - 50 * (canvas.height / 400), canvas.width, 50 * (canvas.height / 400)); // Scale grass height

                ctx.fillStyle = '#c1440e'; // Brick red for track
                ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

                ctx.strokeStyle = 'white'; // White for lane lines
                ctx.lineWidth = 2;

                // Draw horizontal lane dividers
                for (let i = 0; i <= numLanes; i++) {
                    const y = groundY + i * laneHeight;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }

                const interval = 100 * (canvas.width / 600); // Scale interval based on canvas width
                const dashLength = 5 * (canvas.height / 400); // Scale dash length
                const playerPosition = runners.find(r => r.isPlayer).position; // Use player's position for ground scrolling
                const offset = playerPosition % interval;

                for (let xi = -interval; xi < canvas.width + interval; xi += interval) {
                    const draw_x = xi - offset;
                    const relative = draw_x - canvas.width / 2; // Relative to canvas center
                    const meter = Math.round((playerPosition + relative) / pixelsPerMeter); // Meter calculation

                    // Draw short vertical dash at the stickman's ground level (for player's lane)
                    const playerLaneGroundY = groundY + (runners.find(r => r.isPlayer).lane - 1) * laneHeight + laneHeight / 2;
                    ctx.beginPath();
                    ctx.moveTo(draw_x, playerLaneGroundY - dashLength / 2);
                    ctx.lineTo(draw_x, playerLaneGroundY + dashLength / 2);
                    ctx.stroke();

                    // Only draw 100m sign if it's not the finish line
                    if (meter % 10 === 0 && meter >= 0 && meter < 100) { // Changed condition to < 100
                        ctx.fillStyle = 'white';
                        ctx.fillRect(draw_x - 15 * (canvas.width / 600), groundY - 25 * (canvas.height / 400), 30 * (canvas.width / 600), 15 * (canvas.height / 400));
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                        ctx.fillText(meter + 'm', draw_x - 10 * (canvas.width / 600), groundY - 13 * (canvas.height / 400));
                    }

                    if (meter === 0) {
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(draw_x, groundY);
                        ctx.lineTo(draw_x, canvas.height);
                        ctx.stroke();
                        ctx.lineWidth = 2;
                        ctx.fillStyle = 'white';
                        ctx.fillRect(draw_x - 35 * (canvas.width / 600), groundY - 25 * (canvas.height / 400), 30 * (canvas.width / 600), 15 * (canvas.height / 400));
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                        ctx.fillText('Start', draw_x - 30 * (canvas.width / 600), groundY - 13 * (canvas.height / 400));

                        for (let i = 1; i <= numLanes; i++) {
                            ctx.save();
                            ctx.translate(draw_x - 10 * (canvas.width / 600), groundY + (i - 0.5) * laneHeight);
                            ctx.rotate(Math.PI / 2);
                            ctx.fillStyle = 'white';
                            ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                            ctx.fillText(i, 0, 0);
                            ctx.restore();
                        }
                    }

                    if (meter === 100) {
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.moveTo(draw_x, groundY);
                        ctx.lineTo(draw_x, canvas.height);
                        ctx.stroke();
                        ctx.lineWidth = 2;
                        ctx.fillStyle = 'white';
                        ctx.fillRect(draw_x - 35 * (canvas.width / 600), groundY - 25 * (canvas.height / 400), 30 * (canvas.width / 600), 15 * (canvas.height / 400));
                        ctx.fillStyle = 'black';
                        ctx.font = `${12 * (canvas.width / 600)}px Arial`;
                        ctx.fillText('Finish', draw_x - 35 * (canvas.width / 600), groundY - 13 * (canvas.height / 400));
                    }
                }
            }

            // Helper function to draw a rounded rectangle (kept for potential future use or other elements)
            function roundRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            // Renamed from drawStickman to drawRunner and accepts a runner object
            function drawRunner(runner) {
                ctx.lineWidth = 2 * (canvas.width / 600);
                ctx.save();

                const isIdleRelaxed = (gameState === 'idle' || runner.reachedRelaxPoint); // Relaxed standing after race or before start
                const isReadyToRun = (gameState === 'countdown'); // Specific pose for countdown

                let scaledHeight = canvas.height / 400;

                // Calculate runner's screen X position relative to the player's position
                const player = runners.find(r => r.isPlayer);
                let screenX = canvas.width / 2 + (runner.position - player.position);

                // The runner's Y (hip position) is already updated in the update() function
                let hipY = runner.y;

                let hipLeft, hipRight, shoulderLeft, shoulderRight, headX, headY;
                let neckBaseX, neckBaseY; // Base of the neck (middle of shoulders)
                let neckTopX, neckTopY;   // Top of the neck (where head attaches)

                let legAngles = [0, 0];
                let kneeBends = [0, 0];
                let armAngles = [0, 0];

                let currentTorsoThickness;
                let currentElbowBend;
                let armSwingAmpRight, armSwingAmpLeft;
                let gaitAmplitude, frontKneeBend, backKneeBendMax, backKneeBendMultiplier;

                // Computer runners inherit player's "Right Direction" settings for their animation
                currentTorsoThickness = parseFloat(document.getElementById('torsoThickness').value);
                currentElbowBend = parseFloat(document.getElementById('elbowBend').value);
                gaitAmplitude = parseFloat(document.getElementById('gaitAmplitude').value);
                frontKneeBend = parseFloat(document.getElementById('frontKneeBend').value);
                backKneeBendMax = parseFloat(document.getElementById('backKneeBendMax').value);
                backKneeBendMultiplier = parseFloat(document.getElementById('backKneeBendMultiplier').value);

                if (runner.isPlayer) {
                    armSwingAmpRight = parseFloat(armSwingAmplitudeRightSelect.value);
                    armSwingAmpLeft = parseFloat(armSwingAmplitudeLeftSelect.value);
                    // Apply stride length multiplier to player's gait amplitude
                    gaitAmplitude *= parseFloat(strideLengthMultiplierSelect.value);
                } else {
                    armSwingAmpRight = parseFloat(armSwingAmplitudeSelect.value); // Computer's general arm swing
                    armSwingAmpLeft = parseFloat(armSwingAmplitudeSelect.value); // Computer's general arm swing
                }


                if (isIdleRelaxed) {
                    const hipSpread = 3 * (canvas.width / 600);
                    hipLeft = { x: screenX - hipSpread, y: hipY };
                    hipRight = { x: screenX + hipSpread, y: hipY };
                    shoulderLeft = { x: screenX - currentTorsoThickness * (canvas.width / 600), y: hipY - 25 * scaledHeight };
                    shoulderRight = { x: screenX + currentTorsoThickness * (canvas.width / 600), y: hipY - 25 * scaledHeight };

                    // Neck base is middle of shoulders
                    neckBaseX = shoulderLeft.x + (shoulderRight.x - shoulderLeft.x) / 2;
                    neckBaseY = shoulderLeft.y;

                    // Neck top is slightly above neck base
                    const neckHeight = 2 * scaledHeight; // Even tinier neck
                    neckTopX = neckBaseX;
                    neckTopY = neckBaseY - neckHeight;

                    // Head is centered on neck top
                    headX = neckTopX;
                    headY = neckTopY - 10 * scaledHeight; // Head radius is 10*scaledHeight

                    // Arms for idle pose (hands on hips)
                    const handXOffset = 10 * (canvas.width / 600);
                    const handYOffset = 5 * scaledHeight;
                    const leftHandTarget = {
                        x: hipLeft.x - handXOffset,
                        y: hipLeft.y - handYOffset
                    };
                    const rightHandTarget = {
                        x: hipRight.x + handXOffset,
                        y: hipRight.y - handYOffset
                    };
                    // Pass a smaller multiplier for arm lengths in idle pose
                    drawArmToHand(shoulderLeft, leftHandTarget, runner.color, 0.7); // Reduced length
                    drawArmToHand(shoulderRight, rightHandTarget, runner.color, 0.7); // Reduced length

                    // Legs for idle pose
                    legAngles = [0, 0];
                    kneeBends = [0, 0];

                    // Torso for idle pose
                    ctx.beginPath();
                    ctx.moveTo(shoulderLeft.x, shoulderLeft.y);
                    ctx.lineTo(shoulderRight.x, shoulderRight.y);
                    ctx.lineTo(hipRight.x, hipRight.y);
                    ctx.lineTo(hipLeft.x, hipLeft.y);
                    ctx.closePath();
                    ctx.strokeStyle = runner.legColor; // Torso matches leg color
                    ctx.stroke();

                } else if (isReadyToRun) {
                    // Ready to run pose
                    const hipSpread = 5 * (canvas.width / 600);
                    const hipForwardLean = 10 * (canvas.width / 600);
                    const shoulderForwardLean = 15 * (canvas.width / 600);
                    const headForwardLean = 10 * (canvas.width / 600);

                    hipLeft = { x: screenX - hipSpread + hipForwardLean, y: hipY };
                    hipRight = { x: screenX + hipSpread + hipForwardLean, y: hipY };
                    shoulderLeft = { x: screenX - currentTorsoThickness * (canvas.width / 600) + shoulderForwardLean, y: hipY - 25 * scaledHeight };
                    shoulderRight = { x: screenX + currentTorsoThickness * (canvas.width / 600) + shoulderForwardLean, y: hipY - 25 * scaledHeight };

                    // Neck base is middle of shoulders
                    neckBaseX = shoulderLeft.x + (shoulderRight.x - shoulderLeft.x) / 2;
                    neckBaseY = shoulderLeft.y;

                    // Neck top is slightly above neck base
                    const neckHeight = 2 * scaledHeight; // Even tinier neck
                    neckTopX = neckBaseX;
                    neckTopY = neckBaseY - neckHeight;

                    // Head is centered on neck top
                    headX = neckTopX + headForwardLean; // Head also leans forward
                    headY = neckTopY - 10 * scaledHeight;

                    // Legs for ready to run pose (staggered, bent)
                    legAngles = [-0.5, 0.5]; // One leg back, one forward
                    kneeBends = [0.8, 0.5]; // More bend on back leg

                    // Arms for ready to run pose (one forward, one back, bent)
                    const armBend = 1.5; // Significant elbow bend
                    drawArm(shoulderLeft, upperArmLen * scaledHeight, 0.8, lowerArmLen * scaledHeight, armBend, runner.color); // Arm forward
                    drawArm(shoulderRight, upperArmLen * scaledHeight, -0.8, lowerArmLen * scaledHeight, armBend, runner.color); // Arm back

                    // Torso for ready to run pose
                    ctx.beginPath();
                    ctx.moveTo(shoulderLeft.x, shoulderLeft.y);
                    ctx.lineTo(shoulderRight.x, shoulderRight.y);
                    ctx.lineTo(hipRight.x, hipRight.y);
                    ctx.lineTo(hipLeft.x, hipLeft.y);
                    ctx.closePath();
                    ctx.strokeStyle = runner.legColor; // Torso matches leg color
                    ctx.stroke();

                } else { // Running or jumping pose
                    const hipSpread = 0; // No hip spread when running
                    hipLeft = { x: screenX - hipSpread, y: hipY };
                    hipRight = { x: screenX + hipSpread, y: hipY };
                    shoulderLeft = { x: screenX - currentTorsoThickness * (canvas.width / 600), y: hipY - 25 * scaledHeight };
                    shoulderRight = { x: screenX + currentTorsoThickness * (canvas.width / 600), y: hipY - 25 * scaledHeight };

                    // Neck base is middle of shoulders
                    neckBaseX = shoulderLeft.x + (shoulderRight.x - shoulderLeft.x) / 2;
                    neckBaseY = shoulderLeft.y;

                    // Neck top is slightly above neck base
                    const neckHeight = 2 * scaledHeight; // Even tinier neck
                    neckTopX = neckBaseX;
                    neckTopY = neckBaseY - neckHeight;

                    // Head is centered on neck top
                    headX = neckTopX;
                    headY = neckTopY - 10 * scaledHeight; // Head radius is 10*scaledHeight


                    // Torso for running/jumping
                    ctx.beginPath();
                    ctx.moveTo(shoulderLeft.x, shoulderLeft.y);
                    ctx.lineTo(shoulderRight.x, shoulderRight.y);
                    ctx.lineTo(screenX, hipY);
                    ctx.lineTo(shoulderLeft.x, shoulderLeft.y);
                    ctx.closePath(); // Close path for torso
                    ctx.strokeStyle = runner.legColor; // Torso matches leg color
                    ctx.stroke();

                    // Legs for running/jumping
                    if (runner.isPlayer && runner.isCelebrating) {
                        // Celebration pose: arms up, legs slightly bent
                        legAngles = [0.1, -0.1];
                        kneeBends = [0.5, 0.5];
                        armAngles = [-Math.PI / 2, Math.PI / 2]; // Both arms up
                        const celebrationElbowBend = 1.0;
                        drawArm(shoulderLeft, upperArmLen * scaledHeight, armAngles[0], lowerArmLen * scaledHeight, celebrationElbowBend, runner.color);
                        drawArm(shoulderRight, upperArmLen * scaledHeight, armAngles[1], lowerArmLen * scaledHeight, celebrationElbowBend, runner.color);
                    } else {
                        const phase = ((runner.stepCycle % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                        legAngles = [
                            Math.sin(phase) * gaitAmplitude,
                            Math.sin(phase + Math.PI) * gaitAmplitude
                        ];
                        kneeBends = legAngles.map(a => {
                            const isBack = (a < 0);
                            return isBack ? Math.min(backKneeBendMax, -a * backKneeBendMultiplier) : frontKneeBend;
                        });
                        if (runner.isCrouching) {
                            kneeBends = kneeBends.map(b => b + parseFloat(document.getElementById('crouchExtraBend').value));
                        }

                        // Arms for running/jumping
                        const armPhase = phase + Math.PI;
                        armAngles = [
                            -Math.sin(armPhase) * armSwingAmpRight, // Right arm
                            -Math.sin(armPhase + Math.PI) * armSwingAmpLeft  // Left arm
                        ];

                        const bends = armAngles.map(a => Math.abs(Math.sin(a)) * currentElbowBend + 0.1); // Added a small constant bend

                        drawArm(shoulderLeft, upperArmLen * scaledHeight, armAngles[0], lowerArmLen * scaledHeight, bends[0], runner.color);
                        drawArm(shoulderRight, upperArmLen * scaledHeight, armAngles[1], lowerArmLen * scaledHeight, bends[1], runner.color);
                    }
                }

                let flipped = runner.dir === -1;
                if (flipped && !isIdleRelaxed && !isReadyToRun) { // Only flip if running, not in idle/countdown
                    ctx.translate(screenX, 0);
                    ctx.scale(-1, 1);
                    ctx.translate(-screenX, 0);
                }

                // Draw hips (balls) - now matching legColor
                ctx.beginPath();
                ctx.arc(hipLeft.x, hipLeft.y, 3 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = runner.legColor; // Use runner's leg color for hip balls
                ctx.fill();
                ctx.beginPath();
                ctx.arc(hipRight.x, hipRight.y, 3 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = runner.legColor; // Use runner's leg color for hip balls
                ctx.fill();

                // Draw shoulders
                ctx.beginPath();
                ctx.arc(shoulderLeft.x, shoulderLeft.y, 2.5 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = runner.legColor; // Shoulder circles match leg color
                ctx.fill();
                ctx.beginPath();
                ctx.arc(shoulderRight.x, shoulderRight.y, 2.5 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = runner.legColor; // Shoulder circles match leg color
                ctx.fill();

                // Head and Face
                ctx.beginPath();
                ctx.arc(headX, headY, 10 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = '#D3D3D3';
                ctx.fill();
                ctx.strokeStyle = runner.color; // Use runner's body color for head outline
                ctx.stroke();
                // Face direction: 1 for right, 0 for straight, -1 for left
                let faceDir = 0; // Default to straight
                if (isReadyToRun) {
                    faceDir = 1; // Face right at start
                } else if (!isIdleRelaxed) { // If running/jumping
                    faceDir = flipped ? -runner.dir : runner.dir;
                }
                drawFace(headX, headY, runner.expression, faceDir); // Pass runner's specific expression

                // Draw very tiny neck
                ctx.beginPath();
                ctx.strokeStyle = runner.color; // Neck matches body color
                ctx.moveTo(neckBaseX, neckBaseY); // Middle of shoulders
                ctx.lineTo(neckTopX, neckTopY); // Connect to base of head (adjusted to be tiny)
                ctx.stroke();

                // Draw legs (passing legColor for upper, body color for lower)
                drawLeg(hipLeft, upperLegLen * scaledHeight, legAngles[0], lowerLegLen * scaledHeight, kneeBends[0], runner.legColor, runner.color);
                drawLeg(hipRight, upperLegLen * scaledHeight, legAngles[1], lowerLegLen * scaledHeight, kneeBends[1], runner.legColor, runner.color);

                ctx.restore();
            }

            // Modified drawLeg function to accept upperLegColor and lowerLegColor
            function drawLeg(hip, upperLen, angle1, lowerLen, bendAmount, upperLegColor, lowerLegColor) {
                ctx.save();

                const jointX = hip.x + Math.sin(angle1) * upperLen;
                const jointY = hip.y + Math.cos(angle1) * upperLen;
                const lowerLegAngle = angle1 - bendAmount;
                const endX = jointX + Math.sin(lowerLegAngle) * lowerLen;
                const endY = jointY + Math.cos(lowerLegAngle) * lowerLen;

                // Draw upper leg (hip to knee) with upperLegColor
                ctx.strokeStyle = upperLegColor;
                ctx.beginPath();
                ctx.moveTo(hip.x, hip.y);
                ctx.lineTo(jointX, jointY);
                ctx.stroke();

                // Draw lower leg (knee to foot) with lowerLegColor (body color)
                ctx.strokeStyle = lowerLegColor;
                ctx.beginPath();
                ctx.moveTo(jointX, jointY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                // Draw foot as a simple white circle with white outline
                ctx.beginPath();
                const scaledFootRadius = footRadius * (canvas.width / 600);
                ctx.arc(endX, endY, scaledFootRadius, 0, Math.PI * 2);
                ctx.fillStyle = 'white';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.stroke();

                ctx.restore();
            }

            // Modified drawArm function to accept color
            function drawArm(start, len1, angle1, len2, bendAmount, color) {
                ctx.save();
                ctx.strokeStyle = color; // Use runner's body color for arms

                const jointX = start.x + Math.sin(angle1) * len1;
                const jointY = start.y + Math.cos(angle1) * len1;
                const bendAngle = angle1 + bendAmount;
                const endX = jointX + Math.sin(bendAngle) * (len2 * 0.7); // Reduced lower arm length
                const endY = jointY + Math.cos(bendAngle) * (len2 * 0.7); // Reduced lower arm length

                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(jointX, jointY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(endX, endY, 2 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = color; // Use runner's body color for hands
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            // drawArmToHand is used for the idle pose now
            function drawArmToHand(shoulderPos, handPos, color, lengthMultiplier = 1) {
                ctx.save();
                ctx.strokeStyle = color; // Use runner's body color for arms

                const dx = handPos.x - shoulderPos.x;
                const dy = handPos.y - shoulderPos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                let elbowX, elbowY, finalHandX = handPos.x, finalHandY = handPos.y;

                const scaledUpperArmLen = upperArmLen * (canvas.height / 400) * lengthMultiplier; // Apply multiplier
                const scaledLowerArmLen = lowerArmLen * (canvas.height / 400) * lengthMultiplier; // Apply multiplier

                if (dist > scaledUpperArmLen + scaledLowerArmLen) {
                    const ratio = (scaledUpperArmLen + scaledLowerArmLen) / dist;
                    elbowX = shoulderPos.x + dx * (scaledUpperArmLen / dist);
                    elbowY = shoulderPos.y + dy * (scaledUpperArmLen / dist);
                    finalHandX = shoulderPos.x + dx * ratio;
                    finalHandY = shoulderPos.y + dy * ratio;
                } else {
                    const cosAngle = (scaledUpperArmLen**2 + dist**2 - scaledLowerArmLen**2) / (2 * scaledUpperArmLen * dist);
                    const angleElbow = Math.acos(Math.max(-1, Math.min(1, cosAngle)));
                    const targetAngle = Math.atan2(dy, dx);
                    const sign = (handPos.x < shoulderPos.x) ? 1 : -1;
                    const shoulderAngle = targetAngle + sign * angleElbow;
                    elbowX = shoulderPos.x + Math.cos(shoulderAngle) * scaledUpperArmLen;
                    elbowY = shoulderPos.y + Math.sin(shoulderAngle) * scaledUpperArmLen;
                }

                ctx.beginPath();
                ctx.moveTo(shoulderPos.x, shoulderPos.y);
                ctx.lineTo(elbowX, elbowY);
                ctx.lineTo(finalHandX, finalHandY);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(finalHandX, finalHandY, 2 * (canvas.width / 600), 0, Math.PI * 2);
                ctx.fillStyle = color; // Use runner's body color for hands
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }


            function drawFace(x, y, expression, faceDir) {
                const scaleFactor = canvas.width / 600;
                const eyeGap = 4 * scaleFactor, eyeY = -3 * scaleFactor, mouthY = 3 * scaleFactor;
                const eyeRadius = 2.5 * scaleFactor, pupilRadius = 1.2 * scaleFactor;
                const offsetX = faceDir === 1 ? 2 * scaleFactor : faceDir === -1 ? -2 * scaleFactor : 0;
                const mouthX = offsetX;
                const leftX = -eyeGap + offsetX;
                const rightX = eyeGap + offsetX;

                ctx.save();
                ctx.translate(x, y);

                if (isBlinking) {
                    ctx.beginPath();
                    ctx.lineWidth = 1 * scaleFactor;
                    ctx.moveTo(leftX - eyeRadius, eyeY);
                    ctx.lineTo(leftX + eyeRadius, eyeY);
                    ctx.moveTo(rightX - eyeRadius, eyeY);
                    ctx.lineTo(rightX + eyeRadius, eyeY);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.lineWidth = 0.5 * scaleFactor;
                    ctx.arc(leftX, eyeY, eyeRadius, 0, Math.PI * 2);
                    ctx.arc(rightX, eyeY, eyeRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();

                    ctx.fillStyle = 'blue';
                    ctx.beginPath();
                    ctx.arc(leftX, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.arc(rightX, eyeY, pupilRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.lineWidth = 1 * scaleFactor;
                if (expression === 'happy') {
                    ctx.arc(mouthX, mouthY - 2 * scaleFactor, 5 * scaleFactor, 0, Math.PI, false);
                } else if (expression === 'sad') {
                    ctx.arc(mouthX, mouthY + 2 * scaleFactor, 5 * scaleFactor, 0, Math.PI, true);
                } else if (expression === 'angry') {
                    ctx.moveTo(mouthX - 3 * scaleFactor, mouthY);
                    ctx.lineTo(mouthX + 3 * scaleFactor, mouthY);
                } else if (expression === 'surprised') {
                    ctx.arc(mouthX, mouthY, 2.5 * scaleFactor, 0, Math.PI * 2);
                } else if (expression === 'tired') {
                    ctx.moveTo(mouthX - 4 * scaleFactor, mouthY + 2 * scaleFactor);
                    ctx.lineTo(mouthX + 4 * scaleFactor, mouthY + 2 * scaleFactor);
                } else if (expression === 'trying') {
                    ctx.moveTo(mouthX - 4 * scaleFactor, mouthY);
                    ctx.lineTo(mouthX + 4 * scaleFactor, mouthY);
                } else {
                    ctx.moveTo(mouthX - 4 * scaleFactor, mouthY);
                    ctx.lineTo(mouthX + 4 * scaleFactor, mouthY);
                }
                ctx.stroke();

                ctx.restore();
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGround();
                runners.forEach(runner => {
                    drawRunner(runner);
                });
                drawStopwatch();
                drawCountdownMessage();
                drawBestTimes();
            }

            function loop() {
                updateDimensions();
                update();
                draw();
                animationFrameId = requestAnimationFrame(loop);
            }

            // Event Listeners for sliders
            document.getElementById('speed').addEventListener('input', function() {
                document.getElementById('speedValue').textContent = this.value;
            });
            document.getElementById('gaitAmplitude').addEventListener('input', function() {
                document.getElementById('gaitAmplitudeValue').textContent = this.value;
            });
            document.getElementById('stepFrequency').addEventListener('input', function() {
                document.getElementById('stepFrequencyValue').textContent = this.value;
            });
            document.getElementById('frontKneeBend').addEventListener('input', function() {
                document.getElementById('frontKneeBendValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMax').addEventListener('input', function() {
                document.getElementById('backKneeBendMaxValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMultiplier').addEventListener('input', function() {
                document.getElementById('backKneeBendMultiplierValue').textContent = this.value;
            });
            document.getElementById('gaitAmplitudeLeft').addEventListener('input', function() {
                document.getElementById('gaitAmplitudeLeftValue').textContent = this.value;
            });
            document.getElementById('stepFrequencyLeft').addEventListener('input', function() {
                document.getElementById('stepFrequencyLeftValue').textContent = this.value;
            });
            document.getElementById('frontKneeBendLeft').addEventListener('input', function() {
                document.getElementById('frontKneeBendLeftValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMaxLeft').addEventListener('input', function() {
                document.getElementById('backKneeBendMaxLeftValue').textContent = this.value;
            });
            document.getElementById('backKneeBendMultiplierLeft').addEventListener('input', function() {
                document.getElementById('backKneeBendMultiplierLeftValue').textContent = this.value;
            });
            document.getElementById('elbowBend').addEventListener('input', function() {
                document.getElementById('elbowBendValue').textContent = this.value;
            });
            document.getElementById('elbowBendLeft').addEventListener('input', function() {
                document.getElementById('elbowBendLeftValue').textContent = this.value;
            });
            document.getElementById('torsoThickness').addEventListener('input', function() {
                document.getElementById('torsoThicknessValue').textContent = this.value;
            });
            document.getElementById('torsoThicknessLeft').addEventListener('input', function() {
                document.getElementById('torsoThicknessLeftValue').textContent = this.value;
            });
            document.getElementById('crouchExtraBend').addEventListener('input', function() {
                document.getElementById('crouchExtraBendValue').textContent = this.value;
            });
            maxManualSpeedSelect.addEventListener('input', function() {
                document.getElementById('maxManualSpeedValue').textContent = this.value;
            });
            strideLengthMultiplierSelect.addEventListener('input', function() {
                document.getElementById('strideLengthMultiplierValue').textContent = this.value;
            });
            accelDecelSmoothnessSelect.addEventListener('input', function() {
                document.getElementById('accelDecelSmoothnessValue').textContent = this.value;
            });
            armSwingAmplitudeSelect.addEventListener('input', function() {
                document.getElementById('armSwingAmplitudeValue').textContent = this.value;
            });
            armSwingAmplitudeRightSelect.addEventListener('input', function() {
                document.getElementById('armSwingAmplitudeRightValue').textContent = this.value;
            });
            armSwingAmplitudeLeftSelect.addEventListener('input', function() {
                document.getElementById('armSwingAmplitudeLeftValue').textContent = this.value;
            });

            // Toggle UI controls visibility
            toggleControlsButton.addEventListener('click', () => {
                uiControlsContainer.classList.toggle('hidden');
            });

            // Difficulty change listener
            difficultySelect.addEventListener('change', () => {
                currentDifficulty = difficultySelect.value;
                resetGame(); // Reset game to apply new difficulty settings
            });

            loop();
        }); // End of DOMContentLoaded
    </script>
</body>
</html>
